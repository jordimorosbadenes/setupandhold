---
slug: mini-2048
title: "Mini-2048 — implementación y cómo funciona"
description: "Documentación técnica y guía del componente Mini-2048: diseño, estado, animaciones, persistencia y decisiones de implementación."
date: 2026-01-06
tags: [programación, juegos, proyectos]
draft: true
---

Esta entrada documenta en detalle el componente `Mini-2048` incluido en el proyecto: su estructura, la gestión del estado, las animaciones, decisiones de estilo y la integración con el leaderboard. Está pensada para desarrolladores que quieran entender, mantener o extender el componente.

**Nota:** he dejado huecos donde sería útil añadir capturas o GIFs — indico cada lugar con `<!-- INSERT_IMAGE: descripcion -->`.

**Archivos clave**

- `Web/src/components/mini2048/Mini2048.astro`: componente principal (JS + CSS inline).
- `Web/src/content/blog/_mini-2048.md`: este post (documentación).

## Resumen rápido

Mini-2048 es una versión compacta del juego 2048 construida como un componente Astro con JavaScript inline. Soporta:

- Movimiento y fusión de fichas con animación.
- Persistencia local en `localStorage` (clave por defecto `mini-2048-state-v2`).
- Envío de puntuaciones a un leaderboard remoto (API configurable via `apiBase`).
- Accesibilidad básica: roles, labels y estados aria.

## Objetivo y enfoque de diseño

El componente prioriza simplicidad y experiencia en dispositivos móviles y escritorio. Se implementó con pocas dependencias, todo embebido en `Mini2048.astro` para facilitar reuso y despliegue en el sitio.

## Estructura general del componente

- Markup: un `section.m2048` que contiene:
  - Cabecera con título y marcador de puntuación.
  - `div.m2048__board` con 16 `div.m2048__cell` (4x4).
  - Formulario de envío de puntuación (oculto hasta hito/game over).
  - Área de leaderboard con lista y controles.

- JavaScript: todo el comportamiento (estado, lógica del juego, rendering manual y animaciones) está dentro del script del componente.

## Lógica del juego (resumen técnico)

1. Estado inicial
   - `state.board`: array de 16 números (0 = vacío).
   - `state.score`, `state.milestone`, `state.lastMilestone`, etc.
   - `storageKey` configurable vía props; por defecto `mini-2048-state-v2`.

2. Movimiento y fusión
   - La lógica de `slideAndMergeLine` compacta una fila/columna, detecta fusiones y acumula la puntuación ganada.
   - `computeMove(dir)` calcula todas las movimientos (origen/destino) sin mutar el DOM.
   - `animateMoves(result)` crea nodos overlay para animar desplazamientos usando `transform` y `transition`, espera `transitionend` y limpia overlays.

3. Spawn de nuevas fichas
   - Tras realizar movimientos y actualizar `state.next`, se llama a `spawn()` que elige una casilla vacía y coloca 2 o 4 (90% / 10%).
   - Se identifica la casilla recién creada para ejecutar una animación de aparición.

4. Persistencia
   - El juego guarda `state.board`, `score`, `milestone`, `lastMilestone` y flags en `localStorage` con la clave `storageKey`.
   - En el submit de leaderboard se vuelve a guardar el estado cuando procede (para mantener `submittedThisGame`, `submittedMilestone`).

## Animaciones

- Animaciones usadas:
  - `m2048-pop`: efecto breve para casillas que acaban de recibir una fusión (scale ligeramente > 1).
  - `m2048-appear`: nueva animación sin rebote para fichas que aparecen (scale 0 → 1).

- Movimiento:
  - Las fichas en movimiento se animan con `transform` (translate) controlado por `requestAnimationFrame` y `transition` para que `travelMs` controle la duración.
  - La función `animateTo(targetLeft, durationMs)` hace el smooth scroll/animación manualmente con easing.
  - `easing` usa un `cubic-bezier` por defecto para una sensación natural.

## Estilos y temas (light/dark)

- Uso de variables CSS (`--tile-o`, `--accent`, `--cell`, `--card`, etc.) para adaptar colores y opacidades por valor de ficha.
- Problema observado: en modo oscuro las capas semitransparentes (gradientes) de fichas estáticas + overlays en movimiento sumaban opacidad y daban sensación de "doble color". Se probaron soluciones:
  - Aumentar opacidades solo en `prefers-color-scheme: dark`.
  - Hacer que overlays tuvieran fondo coincidente con la celda para "camuflar" los contornos.
  - Alternativas: reducir la opacidad del overlay o hacer background transparente solo en dark.

## Accesibilidad

- `role=application` y `aria-label` en el tablero para indicar el control.
- Cada casilla tiene `aria-label` indicando si está vacía o su valor.
- `data-status` con `aria-live="polite"` para anunciar hitos o estado de juego.

## Leaderboard (integración)

- Prop `apiBase` configurable: si existe, el componente expone un formulario para enviar puntuaciones.
- Reglas del leaderboard:
  - Solo se permite enviar al alcanzar al menos 2048 o al terminar la partida (Game Over).
  - Si el nombre ya existe, solo se actualiza si la nueva puntuación es mejor.
  - Validaciones: nombre 1–16 caracteres; caracteres permitidos: letras, números, espacios y `._-`.

## Código relevante (fragmentos y notas)

- Render del tablero (JSX dentro de Astro): crea 16 celdas:

```jsx
{Array.from({ length: 16 }).map((_, i) => (
  <div class="m2048__cell" data-cell={i} data-value="0" aria-label="Casilla vacía"></div>
))}
```

- Animación de aparición tras `spawn()` (pseudocódigo):

```js
// después de actualizar state.board y llamar spawn()
const newTileIndex = state.board.findIndex((v, i) => v !== 0 && !hadValue[i]);
if (newTileIndex !== -1) {
  const el = cells[newTileIndex];
  el.classList.add('m2048__cell--appear');
  setTimeout(() => el.classList.remove('m2048__cell--appear'), 250);
}
```

## Problemas conocidos y decisiones

- Superposición de colores en dark: causa raíz — overlays temporales y fichas estáticas con gradientes semitransparentes; solución segura: ajustar opacidades por tema o hacer overlays sin fondo sólido.
- Artefactos de render/offset: `will-change: transform` puede causar problemas de rasterización en algunos navegadores; se probó quitarlo para evitar offsets de 1–2px durante la animación.

## Extensión y mantenimiento

- Si quieres pruebas automatizadas, lo recomendable es extraer la lógica pura del juego (funciones de slide/merge/computeMove) a un módulo testable (p. ej. `mini2048/core.js`) y añadir tests unitarios.
- Para separar responsabilidades: mantener el render/DOM y la lógica en módulos distintos facilita refactorizaciones.

## Huecos para imágenes / ejemplos visuales

- Diagrama del DOM del componente: `<!-- INSERT_IMAGE: diagrama-dom-mini-2048 -->`
- Captura del tablero en modo claro y modo oscuro: `<!-- INSERT_IMAGE: tablero-claro-oscuro -->`
- GIF corto mostrando movimiento y aparición de fichas: `<!-- INSERT_IMAGE: gif-movimientos -->`

## Notas para desarrolladores

- Archivo principal: `Web/src/components/mini2048/Mini2048.astro` contiene tanto estilos como lógica. Recomendación: extraer utilidades y tests si el componente crece.
- Variables CSS globales usadas: `--tile-o`, `--accent`, `--accent-2`, `--cell`, `--card`, `--border`, `--text`.

---

Si quieres, puedo:

- Convertir partes de la lógica en módulos JS separados y añadir unit tests.
- Preparar las imágenes/GIFs (pequeñas capturas) si me indicas rutas o las generas localmente.
- Quitar `draft: true` y dejar listo para publicar cuando me digas.

¿Quieres que aplique algún cambio adicional (ej.: extraer lógica a un archivo, generar snippets de test, o añadir ejemplos de llamadas a la API del leaderboard)?
---
# Obligatorios
# (Según el esquema en src/content/config.ts)
title: "TÍTULO AQUÍ"
description: "Resumen corto para listados (1-2 líneas)."
date: 2026-01-03

# Opcionales
# updated: 2026-01-03
# tags: [tag1, tag2]
# draft: true
# hero:
#   src: "https://..."
#   alt: "Texto alternativo (opcional)"
#   height: 250
#   position: "50% 35%" # o "top", "center", "bottom"
---

Escribe aquí el contenido del post en **Markdown**.

## Sección

- Punto 1
- Punto 2
