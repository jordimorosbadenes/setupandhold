---
const {
  storageKey = 'mini-2048-state-v2',
  apiBase = (import.meta as any).env?.PUBLIC_LEADERBOARD_URL ?? '',
} = Astro.props;
---

<section
  class="m2048"
  aria-label="Juego 2048"
  data-storage-key={storageKey}
  data-api-base={apiBase}
>
  <header class="m2048__header">
    <div class="m2048__head">
      <div class="m2048__topline">
        <h2 class="m2048__title">Mini-2048</h2>
        <div class="m2048__score">
          <span class="m2048__label">Puntos</span>
          <span class="m2048__value" data-score>0</span>
        </div>
      </div>
      <div class="m2048__subline">
        <p class="m2048__hint">¡Une las fichas y llega a 2048!</p>
      </div>
    </div>
  </header>

  <div class="m2048__board" data-board tabindex="0" role="application" aria-label="Tablero 2048">
    {Array.from({ length: 16 }).map((_, i) => (
      <div class="m2048__cell" data-cell={i} data-value="0" aria-label="Casilla vacía"></div>
    ))}
    <p class="m2048__note" data-status aria-live="polite"></p>
  </div>

  <div class="m2048__player" data-player>
    <p class="m2048__player-status" data-player-name>No has introducido ningún nombre. ¡No se guardará tu puntuación!</p>
    <div class="m2048__player-actions">
      <button class="button" type="button" data-change-name>Introducir nombre</button>
      <button class="button secondary" type="button" data-new>Nueva partida</button>
    </div>
  </div>

  <section class="m2048__leaderboard" aria-label="Leaderboard">
    <div class="m2048__lb-header">
      <h3 class="m2048__lb-title">Leaderboard</h3>
      <div class="m2048__lb-actions">
        <button class="m2048__lb-info-btn" type="button" data-lb-info aria-label="Info del leaderboard" title="Info">i</button>

        <button
          class="m2048__icon-btn"
          type="button"
          data-lb-refresh
          aria-label="Actualizar leaderboard"
          title="Actualizar"
        >
          <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true" focusable="false">
            <path
              fill="currentColor"
              d="M12 6a6 6 0 0 1 5.65 4H20l-3.2 3.2A.75.75 0 0 1 15.5 12.7V10h1.6A5.1 5.1 0 0 0 12 6.9c-1.62 0-3.1.76-4.05 1.94a.75.75 0 1 1-1.17-.93A6.6 6.6 0 0 1 12 5.4Zm-5.65 8H4l3.2-3.2a.75.75 0 0 1 1.3.53V14H6.9A5.1 5.1 0 0 0 12 17.1c1.62 0 3.1-.76 4.05-1.94a.75.75 0 0 1 1.17.93A6.6 6.6 0 0 1 12 18.6a6 6 0 0 1-5.65-4Z"
            />
          </svg>
        </button>
      </div>
    </div>

    <div class="m2048__lb-cols" aria-hidden="true">
      <span class="m2048__lb-col-rank m2048__lb-rank">#</span>
      <span class="m2048__lb-col-name m2048__lb-name">Player</span>
      <span class="m2048__lb-col-tail">
        <span class="m2048__lb-col-label m2048__lb-score">Score</span>
        <span class="m2048__lb-col-label m2048__lb-max">Max</span>
        <span class="m2048__lb-col-label m2048__lb-date">Date</span>
      </span>
    </div>

    <ol class="m2048__lb-list" data-lb-list></ol>
    <p class="m2048__lb-muted" data-lb-muted></p>

  </section>
</section>

<style>
  .m2048 {
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--card);
    box-shadow: var(--shadow);
    padding: 16px;
  }

  .m2048__header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 12px;
    margin-bottom: 12px;
    flex-wrap: wrap;
  }

  .m2048__head {
    flex: 1;
    min-width: 0;
    display: grid;
    gap: 8px;
  }

  .m2048__topline {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    min-width: 0;
  }

  .m2048__title {
    margin: 0;
    letter-spacing: -0.02em;
  }

    .m2048__actions[hidden] {
      display: none !important;
    }
  .m2048__hint {
    margin: 0;
    color: var(--muted);
    line-height: 1.4;
  }

  .m2048__subline {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 12px;
    flex-wrap: wrap;
  }

  .m2048__score {
    display: grid;
    gap: 2px;
    padding: 8px 10px;
    border: 1px solid var(--border);
    border-radius: 12px;
    background: var(--bg-soft);
    min-width: 104px;
    text-align: right;
  }

  .m2048__label {
    font-size: 0.85rem;
    color: var(--muted);
  }

  .m2048__value {
    font-weight: 800;
    color: var(--text);
    letter-spacing: -0.02em;
  }

  .m2048__btn {
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 10px 12px;
    background: transparent;
    color: var(--muted);
    cursor: pointer;
    transition: background 0.2s ease, color 0.2s ease;
    font: inherit;
    font-size: 0.95rem;
    width: 140px;
  }

  .m2048__btn:hover {
    background: var(--bg-soft);
    color: var(--text);
  }

  .button {
    cursor: pointer;
    font: inherit;
    font-weight: bold;
    font-size: 0.95rem;
  }

  .m2048__btn--small {
    padding: 8px 10px;
    border-radius: 10px;
  }

  .m2048__icon-btn {
    border: 1px solid var(--border);
    border-radius: 10px;
    width: 34px;
    height: 34px;
    display: grid;
    place-items: center;
    background: transparent;
    color: var(--muted);
    cursor: pointer;
    transition: background 0.2s ease, color 0.2s ease;
  }

  .m2048__icon-btn:hover {
    background: var(--bg-soft);
    color: var(--text);
  }

  .m2048__icon-btn[disabled] {
    opacity: 0.65;
    cursor: not-allowed;
  }

  @keyframes m2048-spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  .m2048__icon-btn[data-loading='1'] svg {
    animation: m2048-spin 650ms linear infinite;
  }

  .m2048__board {
    --base-clamp: clamp(1.0rem, 2.2vw, 1.35rem);
    --mobile-clamp: clamp(1.5rem, 5vw, 2.0rem);
    --tile-font-size: var(--base-clamp);
    position: relative;
    user-select: none;
    touch-action: none;
    outline: none;
    display: grid;
    grid-template-columns: repeat(4, minmax(0, 1fr));
    gap: 10px;
    padding: 12px;
    border-radius: calc(var(--radius) - 6px);
    border: 1px solid var(--border);
    background: var(--bg-soft);
    overflow: hidden;
  }

  /* Overlay + tiles are created at runtime via JS.
     Astro component CSS is scoped, so these MUST be :global to apply. */
  .m2048__board :global(.m2048__overlay) {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 2;
  }

  .m2048__board:focus {
    border-color: color-mix(in srgb, var(--accent) 35%, var(--border));
  }

  .m2048[data-gameover] .m2048__board::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.2);
    z-index: 5;
  }

  :global([data-theme="dark"]) .m2048[data-gameover] .m2048__board::before {
    background: rgba(255, 255, 255, 0.3);
  }

  .m2048__cell {
    position: relative;
    z-index: 1;
    aspect-ratio: 1 / 1;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: var(--card);
    display: grid;
    place-items: center;
    font-weight: 900;
    letter-spacing: -0.03em;
    font-size: var(--tile-font-size);
    color: var(--text);
    font-variant-numeric: tabular-nums;
    overflow: hidden;
  }

  .m2048__cell--small-text {
    font-size: calc(0.8 * var(--tile-font-size));
  }

  /* Color sin inventar paleta: gradiente con accent/accent-2 y opacidad por valor. */
  .m2048__cell::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, var(--accent), var(--accent-2));
    opacity: var(--tile-o, 0);
    pointer-events: none;
  }

  .m2048__cell[data-value='0'] {
    color: transparent;
  }

  .m2048__cell[data-value='2'] { --tile-o: 0.10; }
  .m2048__cell[data-value='4'] { --tile-o: 0.14; }
  .m2048__cell[data-value='8'] { --tile-o: 0.18; }
  .m2048__cell[data-value='16'] { --tile-o: 0.22; }
  .m2048__cell[data-value='32'] { --tile-o: 0.26; }
  .m2048__cell[data-value='64'] { --tile-o: 0.30; }
  .m2048__cell[data-value='128'] { --tile-o: 0.34; }
  .m2048__cell[data-value='256'] { --tile-o: 0.38; }
  .m2048__cell[data-value='512'] { --tile-o: 0.42; }
  .m2048__cell[data-value='1024'] { --tile-o: 0.46; }
  .m2048__cell[data-value='2048'] { --tile-o: 0.55; }

  .m2048__cell:not([data-value='0']):not([data-value='2']):not([data-value='4']):not([data-value='8']):not([data-value='16']):not([data-value='32']):not([data-value='64']):not([data-value='128']):not([data-value='256']):not([data-value='512']):not([data-value='1024']):not([data-value='2048']) { --tile-o: 0.65; }

  .m2048__board :global(.m2048__tile) {
    position: absolute;
    z-index: 3;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: var(--card);
    display: grid;
    place-items: center;
    font-weight: 900;
    letter-spacing: -0.03em;
    font-size: var(--tile-font-size);
    color: var(--text);
    overflow: hidden;
    pointer-events: none;
    font-variant-numeric: tabular-nums;
  }

  .m2048__board :global(.m2048__tile--small-text) {
    font-size: calc(0.8 * var(--tile-font-size));
  }

  .m2048__board :global(.m2048__tile)::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, var(--accent), var(--accent-2));
    opacity: var(--tile-o, 0);
    pointer-events: none;
  }

  .m2048__board :global(.m2048__tile)[data-value='0'] {
    color: transparent;
  }

  .m2048__board :global(.m2048__tile)[data-value='2'] { --tile-o: 0.10; }
  .m2048__board :global(.m2048__tile)[data-value='4'] { --tile-o: 0.14; }
  .m2048__board :global(.m2048__tile)[data-value='8'] { --tile-o: 0.18; }
  .m2048__board :global(.m2048__tile)[data-value='16'] { --tile-o: 0.22; }
  .m2048__board :global(.m2048__tile)[data-value='32'] { --tile-o: 0.26; }
  .m2048__board :global(.m2048__tile)[data-value='64'] { --tile-o: 0.30; }
  .m2048__board :global(.m2048__tile)[data-value='128'] { --tile-o: 0.34; }
  .m2048__board :global(.m2048__tile)[data-value='256'] { --tile-o: 0.38; }
  .m2048__board :global(.m2048__tile)[data-value='512'] { --tile-o: 0.42; }
  .m2048__board :global(.m2048__tile)[data-value='1024'] { --tile-o: 0.46; }
  .m2048__board :global(.m2048__tile)[data-value='2048'] { --tile-o: 0.55; }

  .m2048__board :global(.m2048__tile):not([data-value='0']):not([data-value='2']):not([data-value='4']):not([data-value='8']):not([data-value='16']):not([data-value='32']):not([data-value='64']):not([data-value='128']):not([data-value='256']):not([data-value='512']):not([data-value='1024']):not([data-value='2048']) { --tile-o: 0.65; }

  @keyframes m2048-pop {
    0% { transform: scale(1); }
    55% { transform: scale(1.2); }
    100% { transform: scale(1); }
  }

  @keyframes m2048-appear {
    0% { transform: scale(0); }
    100% { transform: scale(1); }
  }

  .m2048__cell--pop {
    animation: m2048-pop 200ms ease;
  }

  .m2048__cell--appear {
    animation: m2048-appear 200ms ease;
  }

  .m2048__note {
    position: absolute;
    top: 45%;
    left: 50%;
    transform: translate(-50%, -50%);
    min-height: 1.2em;
    color: var(--muted);
    font-size: 0.95rem;
    transition: opacity 1s ease-out;
    z-index: 10;
    text-align: center;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 10px 12px;
  }

  .m2048__note:empty {
    display: none;
    margin: 0;
    min-height: 0;
  }

  .m2048__player {
    margin: 12px 0 0;
    display: grid;
    gap: 12px;
  }

  .m2048__player-status {
    margin: 0;
    color: var(--muted);
    font-size: 0.95rem;
  }

  .m2048__player-actions {
    display: flex;
    gap: 12px;
    justify-content: space-between;
  }

  .m2048__actions {
    margin-top: 12px;
    display: flex;
    justify-content: flex-end;
  }

  .m2048__note--accent {
    color: color-mix(in srgb, var(--accent-2) 85%, var(--text));
    font-weight: 800;
    font-size: 1.1rem;
    letter-spacing: -0.01em;
    text-align: center;
    padding: 10px 12px;
    border: 2px solid color-mix(in srgb, var(--accent-2) 80%, var(--border));
    border-radius: 12px;
    min-height: unset;
    margin-top: 12px;
  }

  .m2048[data-gameover='1'] [data-submit-btn].m2048__btn {
    color: color-mix(in srgb, var(--accent) 85%, var(--text));
    font-weight: 800;
    letter-spacing: -0.01em;
    text-align: center;
    border-color: color-mix(in srgb, var(--accent) 35%, var(--border));
    background: color-mix(in srgb, var(--accent) 8%, var(--bg-soft));
    width: 100%;
  }

  .m2048[data-gameover='1'] [data-submit-btn].m2048__btn:hover {
    color: color-mix(in srgb, var(--accent) 90%, var(--text));
    background: color-mix(in srgb, var(--accent) 12%, var(--bg-soft));
  }

  .m2048__leaderboard {
    margin-top: 14px;
    padding-top: 12px;
    border-top: 1px solid var(--border);
    display: grid;
    gap: 10px;
  }

  .m2048__lb-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
  }

  .m2048__lb-actions {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .m2048__lb-info-btn {
    border: 1px solid var(--border);
    border-radius: 10px;
    width: 34px;
    height: 34px;
    display: grid;
    place-items: center;
    background: transparent;
    color: var(--muted);
    cursor: pointer;
    transition: background 0.2s ease, color 0.2s ease;
    user-select: none;
    font-weight: 800;
  }

  .m2048__lb-info-btn:hover {
    background: var(--bg-soft);
    color: var(--text);
  }



  .m2048__lb-title {
    margin: 0;
    font-size: 1rem;
    color: var(--text);
  }

  .m2048__lb-cols {
    display: grid;
    grid-template-columns: auto auto 1fr;
    align-items: center;
    gap: 12px;
    margin: 2px 0 6px;
  }

  .m2048__lb-col-rank {
    color: var(--muted);
    font-variant-numeric: tabular-nums;
    white-space: nowrap;
    text-align: left;
    min-width: 2ch;
    font-size: 1rem;
    line-height: 1;
    width: 2ch;
    display: inline-block;
  }

  .m2048__lb-col-name {
    color: var(--muted);
    font-size: 1rem;
    line-height: 1;
  }

  /* Make header labels share the same visual style as the row cells */
  .m2048__lb-cols .m2048__lb-col-rank {
    color: var(--muted);
    font-variant-numeric: tabular-nums;
    white-space: nowrap;
    text-align: left;
    min-width: 2ch;
    font-size: 1rem;
    line-height: 1;
  }

  .m2048__lb-cols .m2048__lb-col-name {
    /* Match row name styles for identical appearance and height */
    color: var(--text);
    white-space: nowrap;
    min-width: max-content;
    font-size: 1rem;
    line-height: 1;
    font-family: inherit;
    font-weight: 400;
    overflow: visible;
  }

  .m2048__lb-cols .m2048__lb-col-tail .m2048__lb-col-label {
    /* Match row tail label styles */
    color: var(--muted);
    font-variant-numeric: tabular-nums;
    white-space: nowrap;
    text-align: left;
    font-size: inherit;
    letter-spacing: 0.02em;
    text-transform: none;
    line-height: 1;
  }

  /* Ensure header tail aligns to the right and uses the same spacing as rows */
  .m2048__lb-cols .m2048__lb-col-tail {
    display: flex;
    /* Match row tails: left-align header tail so labels line up and don't clip */
    justify-content: flex-start;
    align-items: center;
    gap: 12px;
    min-width: 0;
    /* Make header tail horizontally scrollable so labels can align with rows */
    overflow-x: auto;
    overflow-y: hidden;
    scroll-behavior: smooth;
    scrollbar-width: none;
    -ms-overflow-style: none;
  }

  .m2048__lb-cols .m2048__lb-col-tail::-webkit-scrollbar {
    display: none;
  }

  .m2048__lb-col-tail {
    display: flex;
    justify-content: flex-start;
    gap: 12px;
    min-width: 0;
  }

  .m2048__lb-col-label {
    font-size: 0.72rem;
    color: var(--muted);
    letter-spacing: 0.02em;
    text-transform: none;
    line-height: 1;
    white-space: nowrap;
    min-width: max-content;
    text-align: right;
  }

  .m2048__lb-list {
    margin: 0;
    padding-left: 0;
    list-style: none;
    color: var(--text);
    display: grid;
    gap: 6px;
  }

  /* Leaderboard items are created at runtime via JS.
     Astro component CSS is scoped, so these MUST be :global to apply. */
  .m2048__lb-list :global(.m2048__lb-item) {
    display: grid;
    /* Más espacio para el nombre; la cola tiene ancho acotado. */
    grid-template-columns: auto auto 1fr;
    align-items: center;
    gap: 12px;
  }

  .m2048__lb-list :global(.m2048__lb-rank) {
    color: var(--muted);
    font-variant-numeric: tabular-nums;
    white-space: nowrap;
    text-align: left;
    min-width: 2ch;
    width: 2ch;
    display: inline-block;
    font-size: 1rem;
    line-height: 1;
  }

  .m2048__lb-list :global(.m2048__lb-name) {
    color: var(--text);
    white-space: nowrap;
    min-width: max-content;
    font-size: 1rem;
    line-height: 1;
    font-family: inherit;
    font-weight: 400;
  }

  .m2048__lb-list :global(.m2048__lb-score) {
    color: var(--muted);
    font-variant-numeric: tabular-nums;
    white-space: nowrap;
    text-align: left;
  }

  .m2048__lb-list :global(.m2048__lb-date) {
    color: var(--muted);
    font-variant-numeric: tabular-nums;
    white-space: nowrap;
    text-align: left;
  }

  .m2048__lb-list :global(.m2048__lb-max) {
    color: var(--muted);
    font-variant-numeric: tabular-nums;
    white-space: nowrap;
    text-align: left;
  }

  .m2048__lb-list :global(.m2048__lb-tail) {
    display: flex;
    justify-content: flex-start;
    gap: 12px;
    min-width: 0;
    max-width: 100%;
    overflow-x: auto;
    white-space: nowrap;
    overflow-y: hidden;
    scroll-behavior: smooth;
    white-space: nowrap;
    scrollbar-width: none;
    -ms-overflow-style: none;
    align-items: center;
  }

  .m2048__lb-list :global(.m2048__lb-tail)::-webkit-scrollbar {
    display: none;
  }

  .m2048__lb-list :global(.m2048__lb-tail) :global(.m2048__lb-score),
  .m2048__lb-list :global(.m2048__lb-tail) :global(.m2048__lb-max),
  .m2048__lb-list :global(.m2048__lb-tail) :global(.m2048__lb-date) {
    flex: 0 0 auto;
  }

  /* Asegura que el score no se “corte” al inicio. */
  .m2048__lb-list :global(.m2048__lb-tail) :global(.m2048__lb-score) {
    min-width: 4ch;
    text-align: left;
  }

  @media (max-width: 720px) {
    .m2048__lb-cols {
      grid-template-columns: auto auto 1fr;
      gap: 10px;
    }

    .m2048__lb-list :global(.m2048__lb-item) {
      gap: 10px;
      grid-template-columns: auto auto 1fr;
    }
  }

  .m2048__lb-muted {
    margin: 0;
    min-height: 1.2em;
    color: var(--muted);
    font-size: 0.92rem;
  }

  .m2048__submit {
    display: grid;
    gap: 10px;
    margin-top: 12px;
    padding: 10px;
    border: 1px solid var(--border);
    border-radius: 12px;
    background: var(--bg-soft);
  }

  .m2048__submit[hidden] {
    display: none !important;
  }

  .m2048__submit-row {
    display: grid;
    gap: 6px;
  }

  .m2048__submit-row--actions {
    grid-template-columns: 1fr;
    justify-items: center;
    align-items: center;
    gap: 6px;
  }

  .m2048__submit-row--actions [data-submit-msg] {
    text-align: center;
    min-height: 0;
  }

  .m2048__submit-row--actions [data-submit-msg]:empty {
    display: none;
  }

  .m2048__submit-label {
    color: var(--muted);
    font-size: 0.9rem;
  }

  .m2048__input {
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 10px 12px;
    background: var(--card);
    color: var(--text);
    font: inherit;
    outline: none;
  }

  .m2048__input:focus {
    border-color: color-mix(in srgb, var(--accent) 35%, var(--border));
  }

  @media (max-width: 720px) {
    .m2048 {
      padding: 14px;
    }
    .m2048__score {
      text-align: left;
    }

    /* Números un poco más grandes en móvil (sin tocar escritorio). */
    .m2048__board {
      --tile-font-size: var(--mobile-clamp);
    }

    /* Evita que el texto “baje” ligeramente durante el transform en móvil. */
    .m2048__board :global(.m2048__tile) {
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      font-variant-numeric: tabular-nums;
    }
  }
</style>

<script is:inline>
  (() => {
    // Debug flag: set to 1 to enable developer cheat (Ctrl/Cmd+click new game),
    // set to 0 to disable.
    const DEBUG_CHEAT = 1;
    const init = (root) => {
      if (root.dataset.m2048Init === '1') return;
      root.dataset.m2048Init = '1';

      const boardEl = root.querySelector('[data-board]');
      const scoreEl = root.querySelector('[data-score]');
      const statusEl = root.querySelector('[data-status]');
      const newBtn = root.querySelector('[data-new]');
      const cells = Array.from(root.querySelectorAll('[data-cell]'));
      const lbListEl = root.querySelector('[data-lb-list]');
      const lbColsEl = root.querySelector('.m2048__lb-cols');
      const lbMutedEl = root.querySelector('[data-lb-muted]');
      const lbRefreshBtn = root.querySelector('[data-lb-refresh]');
      const lbInfoEl = root.querySelector('[data-lb-info]');
      const playerEl = root.querySelector('[data-player]');
      const playerNameEl = root.querySelector('[data-player-name]');
      const changeNameBtn = root.querySelector('[data-change-name]');

      if (!boardEl || cells.length !== 16) return;

      // Layer for animated tiles (prevents offset bugs).
      let overlayEl = boardEl.querySelector('.m2048__overlay');
      if (!overlayEl) {
        overlayEl = document.createElement('div');
        overlayEl.className = 'm2048__overlay';
        boardEl.appendChild(overlayEl);
      }

      const size = 4;
      const total = size * size;
      const storageKey = root.getAttribute('data-storage-key') || 'mini-2048-state-v2';
      const apiBase = (root.getAttribute('data-api-base') || '').trim();
      const normalizedApi = apiBase.replace(/\/+$/, '');
      const leaderboardEndpoint = (() => {
        if (!normalizedApi) return '';
        // Allow passing either the base URL or the full endpoint URL.
        if (/\/api\/leaderboard$/i.test(normalizedApi) || /\/leaderboard$/i.test(normalizedApi)) return normalizedApi;
        return `${normalizedApi}/api/leaderboard`;
      })();

      const state = {
        board: new Array(total).fill(0),
        score: 0,
        milestone: 2048,
        lastMilestone: 0,
        submittedMilestone: false,
        currentPlayerName: '',
        lastSubmittedThousand: 0,
      };

      let isAnimating = false;
      let isGameOver = false;
      let submittedThisGame = false;
      let milestoneMessageActive = false;
      let milestoneTimeoutId = null;
      let milestoneStartTime = 0;

      // Hitos para permitir guardar sin terminar la partida.
      // 256, 512, 1024, 2048... con un límite lógico.
      const milestoneMin = 256;
      // Tope de hitos (nota: los hitos son potencias de 2; el último hito será
      // la mayor potencia de 2 <= milestoneMax).
      const milestoneMax = 131972;

      const maxTile = () => {
        let m = 0;
        for (let i = 0; i < state.board.length; i += 1) {
          const v = state.board[i] || 0;
          if (v > m) m = v;
        }
        return m;
      };

      const milestoneForMax = (m) => {
        if (m < milestoneMin) return 0;
        let v = milestoneMin;
        while (v <= milestoneMax / 2 && v * 2 <= m) v *= 2;
        return v;
      };

      const setGameOver = (value) => {
        isGameOver = value;
        if (value) root.setAttribute('data-gameover', '1');
        else root.removeAttribute('data-gameover');
      };

      const setCurrentPlayerName = (name) => {
        state.currentPlayerName = name || '';
        if (name) {
          if (playerEl && playerNameEl && changeNameBtn) {
            playerNameEl.innerHTML = `Estás jugando como <strong style="color: var(--accent);">${name}</strong>. Tu puntuación se guardará.`;
            changeNameBtn.textContent = 'Cambiar nombre';
            changeNameBtn.classList.add('secondary');
            playerEl.style.display = 'grid';
          }
        } else {
          if (playerEl && playerNameEl && changeNameBtn) {
            playerNameEl.textContent = 'No has introducido ningún nombre. ¡No se guardará tu puntuación!';
            changeNameBtn.textContent = 'Introducir nombre';
            changeNameBtn.classList.remove('secondary');
            playerEl.style.display = 'grid';
          }
        }
        save();
      };

      const renderLeaderboard = (entries) => {
        if (!lbListEl) return;

        // Clean up any previous auto-scroll timers (re-render can happen on refresh/submit).
        if (Array.isArray(renderLeaderboard._timers)) {
          renderLeaderboard._timers.forEach((id) => {
            clearTimeout(id);
            clearInterval(id);
          });
        }
        renderLeaderboard._timers = [];
        if (Array.isArray(renderLeaderboard._rafIds)) {
          renderLeaderboard._rafIds.forEach((id) => {
            try { cancelAnimationFrame(id); } catch {}
          });
        }
        renderLeaderboard._rafIds = [];

        lbListEl.innerHTML = '';
        const safe = Array.isArray(entries) ? entries.slice(0, 10) : [];
        if (!safe.length) return;

        const fmtDate = new Intl.DateTimeFormat('es-ES', {
          year: '2-digit',
          month: '2-digit',
          day: '2-digit',
        });

        const startAutoScroll = (el) => {
          if (!el) return;
          const prefersReduced = typeof window !== 'undefined'
            && typeof window.matchMedia === 'function'
            && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
          if (prefersReduced) return;

          const scrollToLeft = (left, smooth) => {
            // Robust across browsers: options object may not be supported everywhere.
            try {
              if (typeof el.scrollTo === 'function') {
                try {
                  el.scrollTo({ left, top: 0, behavior: smooth ? 'smooth' : 'auto' });
                  return;
                } catch {
                  el.scrollTo(left, 0);
                  return;
                }
              }
            } catch {}
            try { el.scrollLeft = left; } catch {}
          };

          // NOTE: native smooth scrolling has an implementation-defined duration.
          // We animate manually so `travelMs` actually controls the speed.
          const animateTo = (targetLeft, durationMs) => {
            const from = Number(el.scrollLeft) || 0;
            const to = Number(targetLeft) || 0;
            const d = Math.max(0, Number(durationMs) || 0);
            if (d <= 0 || from === to) {
              scrollToLeft(to, false);
              return;
            }

            const start = (typeof performance !== 'undefined' && performance.now)
              ? performance.now()
              : Date.now();

            const easeInOutQuad = (t) => (t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2);

            const step = (now) => {
              const current = (typeof now === 'number') ? now : ((typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now());
              const t = Math.min(1, (current - start) / d);
              const eased = easeInOutQuad(t);
              el.scrollLeft = from + (to - from) * eased;
              if (t < 1) {
                const id = requestAnimationFrame(step);
                renderLeaderboard._rafIds.push(id);
              }
            };

            const id = requestAnimationFrame(step);
            renderLeaderboard._rafIds.push(id);
          };

          // Wait one frame so layout/scrollWidth are correct.
          requestAnimationFrame(() => {
            const max = el.scrollWidth - el.clientWidth;
            if (!(max > 4)) return;

            // Start from the left so the score is always the first thing visible.
            scrollToLeft(0, false);

            const dwellLeftMs = 3000; // 6 segundos a la izquierda
            const dwellRightMs = 3000; // 3 segundos a la derecha
            const travelMs = Math.max(1500, Math.min(4500, 1200 + max * 6))

            const cycle = () => {
              const m = el.scrollWidth - el.clientWidth;
              if (!(m > 4)) return;

              // Hold at left.
              scrollToLeft(0, false);
              const t1 = setTimeout(() => {
                // Smooth scroll to right.
                animateTo(m, travelMs);
                const t2 = setTimeout(() => {
                  // Hold at right.
                  scrollToLeft(m, false);
                  const t3 = setTimeout(() => {
                    // Smooth scroll back to left.
                    animateTo(0, travelMs);
                    const t4 = setTimeout(cycle, travelMs + 50);
                    renderLeaderboard._timers.push(t4);
                  }, dwellRightMs);
                  renderLeaderboard._timers.push(t3);
                }, travelMs + 50);
                renderLeaderboard._timers.push(t2);
              }, dwellLeftMs);
              renderLeaderboard._timers.push(t1);
            };

            cycle();
          });
        };

        for (let i = 0; i < safe.length; i += 1) {
          const e = safe[i];
          const li = document.createElement('li');
          li.className = 'm2048__lb-item';

          const rankSpan = document.createElement('span');
          rankSpan.className = 'm2048__lb-rank';
          rankSpan.textContent = String(i + 1);

          const nameSpan = document.createElement('span');
          nameSpan.className = 'm2048__lb-name';
          nameSpan.textContent = String(e?.name ?? '');
          const scoreSpan = document.createElement('span');
          scoreSpan.className = 'm2048__lb-score';
          scoreSpan.textContent = String(e?.score ?? '');

          const createdAt = typeof e?.createdAt === 'number' ? e.createdAt : Number(e?.createdAt);
          const dateSpan = document.createElement('span');
          dateSpan.className = 'm2048__lb-date';
          dateSpan.textContent = Number.isFinite(createdAt)
            ? fmtDate.format(new Date(createdAt * 1000))
            : '';

          const maxSpan = document.createElement('span');
          maxSpan.className = 'm2048__lb-max';
          maxSpan.textContent = String(e?.maxTile ?? '');

          li.appendChild(rankSpan);
          li.appendChild(nameSpan);

          const tail = document.createElement('span');
          tail.className = 'm2048__lb-tail';

          tail.appendChild(scoreSpan);
          tail.appendChild(maxSpan);
          tail.appendChild(dateSpan);
          li.appendChild(tail);
          lbListEl.appendChild(li);
        }

        // After rendering all rows, compute the widest name and fix the name column
        // width so all name cells share the same width (the widest one).
        requestAnimationFrame(() => {
          try {
            const nameEls = Array.from(lbListEl.querySelectorAll('.m2048__lb-name'));
            if (!nameEls.length) return;
            const widths = nameEls.map((el) => {
              const r = el.getBoundingClientRect();
              return Math.ceil(r.width);
            });
            const max = Math.max.apply(null, widths.concat([0]));
            if (max > 0) {
              const cols = `auto ${max}px 1fr`;
              if (lbColsEl && lbColsEl.style) lbColsEl.style.gridTemplateColumns = cols;
              const items = Array.from(lbListEl.querySelectorAll('.m2048__lb-item'));
              items.forEach((it) => { it.style.gridTemplateColumns = cols; });
              nameEls.forEach((el) => { el.style.width = `${max}px`; el.style.display = 'inline-block'; });
              // Also apply same fixed width to the header `Player` label so the
              // whole name column shares identical pixel width.
              try {
                const headerName = lbColsEl ? lbColsEl.querySelector('.m2048__lb-col-name') : null;
                if (headerName) { headerName.style.width = `${max}px`; headerName.style.display = 'inline-block'; }
              } catch (_) {}
            }
          } catch (_) {}
        });
        // Also measure tail columns (score, max, date) and fix their widths so each column
        // uses the maximum width found across rows; align header labels too.
        requestAnimationFrame(() => {
          try {
            const scoreEls = Array.from(lbListEl.querySelectorAll('.m2048__lb-score'));
            const maxEls = Array.from(lbListEl.querySelectorAll('.m2048__lb-max'));
            const dateEls = Array.from(lbListEl.querySelectorAll('.m2048__lb-date'));

            const measureMax = (els, minPx = 0) => {
              if (!els || !els.length) return 0;
              const w = els.map((el) => Math.ceil(el.getBoundingClientRect().width));
              return Math.max.apply(null, w.concat([minPx, 0]));
            };

            const scoreW = measureMax(scoreEls, 24);
            const maxW = measureMax(maxEls, 24);
            const dateW = measureMax(dateEls, 40);

            const headerTail = lbColsEl ? Array.from(lbColsEl.querySelectorAll('.m2048__lb-col-tail .m2048__lb-col-label')) : [];

            if (scoreW > 0) {
              scoreEls.forEach((el) => { el.style.width = `${scoreW}px`; el.style.display = 'inline-block'; });
              if (headerTail[0]) { headerTail[0].style.width = `${scoreW}px`; headerTail[0].style.display = 'inline-block'; }
            }
            if (maxW > 0) {
              maxEls.forEach((el) => { el.style.width = `${maxW}px`; el.style.display = 'inline-block'; });
              if (headerTail[1]) { headerTail[1].style.width = `${maxW}px`; headerTail[1].style.display = 'inline-block'; }
            }
            if (dateW > 0) {
              dateEls.forEach((el) => { el.style.width = `${dateW}px`; el.style.display = 'inline-block'; });
              if (headerTail[2]) { headerTail[2].style.width = `${dateW}px`; headerTail[2].style.display = 'inline-block'; }
            }

            // Start auto-scroll now that widths are stable.
            const tailEls = Array.from(lbListEl.querySelectorAll('.m2048__lb-tail'));
            tailEls.forEach((t) => startAutoScroll(t));
            // Make header tail align exactly with row tail columns and mirror
            // the scrollLeft so labels sit over their corresponding columns.
            try {
              const headerTailEl = lbColsEl ? lbColsEl.querySelector('.m2048__lb-col-tail') : null;
              if (headerTailEl) {
                const firstTail = tailEls[0];
                if (firstTail && firstTail.clientWidth) {
                  try { headerTailEl.style.width = `${firstTail.clientWidth}px`; } catch (_) {}
                }

                if (firstTail && firstTail.scrollWidth > firstTail.clientWidth) {
                  try {
                    // Create an inner wrapper inside the header tail to move with
                    // CSS transforms (GPU-accelerated), avoiding scrollLeft updates
                    // on the header which can cause jank.
                    headerTailEl.style.overflow = 'hidden';
                    // Apply the same fixed column widths to the inner wrapper.
                    let inner = headerTailEl.querySelector('.m2048__lb-col-tail-inner');
                    if (!inner) {
                      inner = document.createElement('div');
                      inner.className = 'm2048__lb-col-tail-inner';
                      // Move existing children into the inner wrapper.
                      while (headerTailEl.firstChild) inner.appendChild(headerTailEl.firstChild);
                      headerTailEl.appendChild(inner);
                      inner.style.display = 'inline-flex';
                      inner.style.gap = '12px';
                      inner.style.willChange = 'transform';
                      inner.style.whiteSpace = 'nowrap';
                    }
                    try {
                      inner.style.width = `${scoreW + maxW + dateW + 24}px`;
                      inner.style.boxSizing = 'content-box';
                    } catch (_) {}
                  } catch (_) {}

                  const firstTailForSync = firstTail;
                  const inner = headerTailEl.querySelector('.m2048__lb-col-tail-inner');
                  const sync = () => {
                    try {
                      const x = Math.max(0, firstTailForSync.scrollLeft || 0);
                      if (inner) inner.style.transform = `translateX(${-x}px)`;
                    } catch (_) {}
                    const id = requestAnimationFrame(sync);
                    renderLeaderboard._rafIds.push(id);
                  };
                  sync();
                }
              }
            } catch (_) {}
          } catch (_) {}
        });
      };

      // Store interval ids for cleanup.
      renderLeaderboard._timers = [];

      const setLbMuted = (text) => {
        if (!lbMutedEl) return;
        lbMutedEl.textContent = text || '';
      };

      const fetchLeaderboard = async () => {
        if (!leaderboardEndpoint) {
          setLbMuted('Leaderboard no configurado.');
          return;
        }
        try {
          if (lbRefreshBtn) {
            lbRefreshBtn.setAttribute('data-loading', '1');
            lbRefreshBtn.disabled = true;
          }
          setLbMuted('Cargando…');
          const res = await fetch(leaderboardEndpoint, { method: 'GET' });
          const data = await res.json();
          if (!res.ok || !data?.ok) throw new Error(data?.error || 'Error');
          renderLeaderboard(data.entries);
          if (!Array.isArray(data.entries) || data.entries.length === 0) setLbMuted('Aún no hay puntuaciones.');
          else setLbMuted('');
        } catch (e) {
          console.error('[Mini-2048] Leaderboard load failed:', e);
          setLbMuted('No se pudo cargar.');
        } finally {
          if (lbRefreshBtn) {
            lbRefreshBtn.removeAttribute('data-loading');
            lbRefreshBtn.disabled = false;
          }
        }
      };

      const submitScore = async (name, opts = {}) => {
        const after = String(opts.after || 'reset'); // 'reset' | 'continue'
        if (!leaderboardEndpoint) {
          return;
        }
        try {

          const maxTileValue = maxTile();

          const res = await fetch(leaderboardEndpoint, {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ name, score: state.score, maxTile: maxTileValue }),
          });
          const data = await res.json();
          if (!res.ok || !data?.ok) throw new Error(data?.error || 'Error');

          renderLeaderboard(data.entries);
          setLbMuted('');

          if (after === 'reset') {
            submittedThisGame = true;
            localStorage.setItem(storageKey, JSON.stringify({ board: state.board, score: state.score, milestone: state.milestone, lastMilestone: state.lastMilestone, submittedMilestone: state.submittedMilestone, submittedThisGame: submittedThisGame, currentPlayerName: state.currentPlayerName, lastSubmittedThousand: state.lastSubmittedThousand }));
            // Keep the board and game over message, hide submit, show new game button
            setStatus('¡Game Over!');
            setGameOver(true);
          } else {
            // En hito, solo ocultamos el formulario y seguimos jugando.
            // setStatus(''); // No limpiar el mensaje de milestone aquí
            state.submittedMilestone = true;
            localStorage.setItem(storageKey, JSON.stringify({ board: state.board, score: state.score, milestone: state.milestone, lastMilestone: state.lastMilestone, submittedMilestone: state.submittedMilestone, submittedThisGame: submittedThisGame, currentPlayerName: state.currentPlayerName, lastSubmittedThousand: state.lastSubmittedThousand }));
          }
        } catch (e) {
          console.error('[Mini-2048] Leaderboard submit failed:', e);
        } finally {
        }
        setCurrentPlayerName(name);
      };

      const rand = (n) => Math.floor(Math.random() * n);
      const emptyIndexes = () => state.board
        .map((v, i) => (v === 0 ? i : -1))
        .filter((i) => i !== -1);

      const spawn = () => {
        const empties = emptyIndexes();
        if (!empties.length) return;
        const idx = empties[rand(empties.length)];
        state.board[idx] = Math.random() < 0.9 ? 2 : 4;
      };

      const save = () => {
        try {
          localStorage.setItem(storageKey, JSON.stringify({ board: state.board, score: state.score, milestone: state.milestone, lastMilestone: state.lastMilestone, submittedMilestone: state.submittedMilestone, submittedThisGame: submittedThisGame, currentPlayerName: state.currentPlayerName, lastSubmittedThousand: state.lastSubmittedThousand }));
        } catch (_) {}
      };

      const render = () => {
        if (scoreEl) scoreEl.textContent = String(state.score);

        for (let i = 0; i < total; i += 1) {
          const v = state.board[i] || 0;
          const el = cells[i];
          if (!el) continue;
          el.textContent = v ? String(v) : '';
          el.setAttribute('data-value', String(v));
          el.setAttribute('aria-label', v ? `Casilla ${v}` : 'Casilla vacía');
          if (v >= 1000) {
            el.classList.add('m2048__cell--small-text');
          } else {
            el.classList.remove('m2048__cell--small-text');
          }
        }

        save();
      };

      const setStatus = (text) => {
        if (!statusEl) return;
        statusEl.textContent = text;
        if (text) {
          statusEl.style.opacity = '1';
          statusEl.classList.add('m2048__note--accent');
        } else {
          statusEl.classList.remove('m2048__note--accent');
        }
      };

      const reset = () => {
        state.board = new Array(total).fill(0);
        state.score = 0;
        state.milestone = 2048;
        state.lastMilestone = 0;
        state.submittedMilestone = false;
        state.lastSubmittedThousand = 0;
        spawn();
        spawn();
        setGameOver(false);
        submittedThisGame = false;
        if (milestoneTimeoutId) {
          clearTimeout(milestoneTimeoutId);
          milestoneTimeoutId = null;
        }
        milestoneMessageActive = false;
        localStorage.setItem(storageKey, JSON.stringify({ board: state.board, score: state.score, milestone: state.milestone, lastMilestone: state.lastMilestone, submittedMilestone: state.submittedMilestone, submittedThisGame: submittedThisGame, currentPlayerName: state.currentPlayerName, lastSubmittedThousand: state.lastSubmittedThousand }));
        setStatus('');
        render();
      };

      const load = () => {
        try {
          const raw = localStorage.getItem(storageKey);
          if (!raw) return false;
          const parsed = JSON.parse(raw);
          if (!parsed || !Array.isArray(parsed.board) || parsed.board.length !== total) return false;
          state.board = parsed.board.map((n) => (typeof n === 'number' ? n : 0));
          state.score = typeof parsed.score === 'number' ? parsed.score : 0;
          state.milestone = typeof parsed.milestone === 'number' ? parsed.milestone : 2048;
          state.lastMilestone = typeof parsed.lastMilestone === 'number' ? parsed.lastMilestone : 0;
          state.submittedMilestone = typeof parsed.submittedMilestone === 'boolean' ? parsed.submittedMilestone : false;
          submittedThisGame = typeof parsed.submittedThisGame === 'boolean' ? parsed.submittedThisGame : false;
          state.currentPlayerName = typeof parsed.currentPlayerName === 'string' ? parsed.currentPlayerName : '';
          state.lastSubmittedThousand = typeof parsed.lastSubmittedThousand === 'number' ? parsed.lastSubmittedThousand : 0;
          setCurrentPlayerName(state.currentPlayerName);
          return true;
        } catch (_) {
          return false;
        }
      };

      const get = (r, c) => state.board[r * size + c];
      const set = (r, c, v) => { state.board[r * size + c] = v; };

      const slideAndMergeLine = (line) => {
        const values = line.filter((n) => n !== 0);
        const out = [];
        let gained = 0;

        for (let i = 0; i < values.length; i += 1) {
          const current = values[i];
          const next = values[i + 1];
          if (next != null && current === next) {
            const merged = current + next;
            out.push(merged);
            gained += merged;
            i += 1;
          } else {
            out.push(current);
          }
        }

        while (out.length < size) out.push(0);
        return { out, gained };
      };

      const buildLines = (dir) => {
        const lines = [];
        for (let r = 0; r < size; r += 1) {
          const row = [r * size + 0, r * size + 1, r * size + 2, r * size + 3];
          if (dir === 'left') lines.push(row);
          else if (dir === 'right') lines.push(row.slice().reverse());
        }
        for (let c = 0; c < size; c += 1) {
          const col = [0 * size + c, 1 * size + c, 2 * size + c, 3 * size + c];
          if (dir === 'up') lines.push(col);
          else if (dir === 'down') lines.push(col.slice().reverse());
        }
        return lines;
      };

      const computeMove = (dir) => {
        const before = state.board.slice();
        const next = before.slice();
        const moves = [];
        const mergeDestinations = [];
        let gained = 0;

        const lines = buildLines(dir);
        for (const lineIdxs of lines) {
          const tiles = lineIdxs
            .filter((idx) => before[idx] !== 0)
            .map((idx) => ({ value: before[idx], from: idx }));

          const out = new Array(size).fill(0);
          let write = 0;
          for (let i = 0; i < tiles.length; i += 1) {
            const a = tiles[i];
            const b = tiles[i + 1];
            if (b && a.value === b.value) {
              const dest = lineIdxs[write];
              const mergedValue = a.value + b.value;
              out[write] = mergedValue;
              gained += mergedValue;
              moves.push({ from: a.from, to: dest, value: a.value, merged: true });
              moves.push({ from: b.from, to: dest, value: b.value, merged: true });
              mergeDestinations.push(dest);
              i += 1;
            } else {
              const dest = lineIdxs[write];
              out[write] = a.value;
              moves.push({ from: a.from, to: dest, value: a.value, merged: false });
            }
            write += 1;
          }

          for (let j = 0; j < size; j += 1) {
            next[lineIdxs[j]] = out[j];
          }
        }

        const changed = before.some((v, i) => v !== next[i]);
        return {
          before,
          next,
          moves,
          gained,
          mergeDestinations: Array.from(new Set(mergeDestinations)),
          changed,
        };
      };

      const animateMoves = async (moveResult) => {
        const isMobile = typeof window !== 'undefined'
          && typeof window.matchMedia === 'function'
          && window.matchMedia('(max-width: 720px)').matches;

        // En móvil damos un pelín más de tiempo y forzamos una secuencia de frames más fiable.
        // En escritorio lo dejamos tal cual para no cambiar sensaciones.
        const duration = isMobile ? 140 : 140;

        // Empieza lentamente (0.2) - la animación acelera gradualmente al inicio
        // Acelera mucho (0.9) - alcanza velocidad máxima rápidamente
        // Decelera suavemente (0.2) - reduce velocidad hacia el final
        // Termina normalmente (1) - llega al destino sin rebote
        const easing = 'cubic-bezier(0.2, 0.9, 0.2, 0.9)';

        // Most reliable: use layout offsets from the real grid items.
        const posForIndex = (idx) => {
          const el = cells[idx];
          return {
            left: el.offsetLeft,
            top: el.offsetTop,
            width: el.offsetWidth,
            height: el.offsetHeight,
          };
        };

        // Hide the text/values where tiles are leaving, to avoid double-vision.
        const leaving = new Set(
          moveResult.moves
            .filter((m) => m.from !== m.to)
            .map((m) => m.from)
        );
        leaving.forEach((idx) => {
          const el = cells[idx];
          if (!el) return;
          el.textContent = '';
          el.setAttribute('data-value', '0');
          el.setAttribute('aria-label', 'Casilla vacía');
        });

        const overlays = [];
        for (const m of moveResult.moves) {
          if (m.from === m.to) continue;

          const from = posForIndex(m.from);
          const to = posForIndex(m.to);

          const tile = document.createElement('div');
          tile.className = 'm2048__tile';
          tile.textContent = String(m.value);
          tile.setAttribute('data-value', String(m.value));
          if (m.value >= 1000) {
            tile.classList.add('m2048__tile--small-text');
          }
          tile.style.left = `${from.left}px`;
          tile.style.top = `${from.top}px`;
          tile.style.width = `${from.width}px`;
          tile.style.height = `${from.height}px`;
          if (isMobile) {
            tile.style.transform = 'translate3d(0px, 0px, 0px)';
            tile.style.transition = 'none';
          } else {
            tile.style.transform = 'translate(0px, 0px)';
            tile.style.transition = `transform ${duration}ms ${easing}`;
          }
          overlayEl.appendChild(tile);
          overlays.push(tile);

          const dx = to.left - from.left;
          const dy = to.top - from.top;
          if (isMobile) {
            // Doble rAF: asegura que el browser “registre” el estado inicial antes de animar.
            requestAnimationFrame(() => {
              tile.style.transition = `transform ${duration}ms ${easing}`;
              requestAnimationFrame(() => {
                tile.style.transform = `translate3d(${dx}px, ${dy}px, 0px)`;
              });
            });
          } else {
            requestAnimationFrame(() => {
              tile.style.transform = `translate(${dx}px, ${dy}px)`;
            });
          }
        }

        if (!overlays.length) return;

        await new Promise((resolve) => {
          let resolved = false;
          let remaining = overlays.length;

          const finish = () => {
            if (resolved) return;
            resolved = true;
            overlays.forEach((el) => el.remove());
            resolve();
          };

          overlays.forEach((el) => {
            const onEnd = (e) => {
              if (e.propertyName !== 'transform') return;
              el.removeEventListener('transitionend', onEnd);
              remaining -= 1;
              if (remaining <= 0) finish();
            };
            el.addEventListener('transitionend', onEnd);
          });

          setTimeout(finish, duration + 120);
        });
      };

      const canMove = () => {
        if (emptyIndexes().length) return true;
        for (let r = 0; r < size; r += 1) {
          for (let c = 0; c < size; c += 1) {
            const v = get(r, c);
            if (c + 1 < size && v === get(r, c + 1)) return true;
            if (r + 1 < size && v === get(r + 1, c)) return true;
          }
        }
        return false;
      };

      const has2048 = () => state.board.some((v) => v === 2048);

      const move = (dir) => {
        if (isAnimating) return;
        if (isGameOver) return;

        const result = computeMove(dir);
        if (!result.changed) return;

        isAnimating = true;
        animateMoves(result)
          .then(() => {
            state.board = result.next;
            state.score += result.gained;
            
            // Remember which cells had values before spawning
            const hadValue = state.board.map(v => v !== 0);
            spawn();
            // Find which cell got a new value
            const newTileIndex = state.board.findIndex((v, i) => v !== 0 && !hadValue[i]);

            let m = milestoneForMax(maxTile());
            let justHitMilestone = Boolean(m && m > (state.lastMilestone || 0));
            if (justHitMilestone) {
              state.lastMilestone = m;
              state.submittedMilestone = false;
            }
            
            // Envío automático si hay nombre
            if (state.currentPlayerName && !submittedThisGame) {
              let shouldSubmit = false;
              let isThousandSubmit = false;
              const currentThousand = Math.floor(state.score / 1000);
              if (currentThousand > state.lastSubmittedThousand) {
                shouldSubmit = true;
                isThousandSubmit = true;
              }
              if (justHitMilestone) shouldSubmit = true;
              if (shouldSubmit) {
                if (isThousandSubmit) state.lastSubmittedThousand = currentThousand;
                submitScore(state.currentPlayerName, { after: 'continue' });
              }
            }
            
            render();

            // Pop the new tile after render
            if (newTileIndex !== -1) {
              const el = cells[newTileIndex];
              if (el) {
                el.classList.remove('m2048__cell--appear');
                // Force reflow so animation works
                void el.offsetWidth;
                el.classList.add('m2048__cell--appear');
                setTimeout(() => el.classList.remove('m2048__cell--appear'), 250);
              }
            }

            if (!canMove()) {
              setGameOver(true);
              setStatus('¡Game Over!');
              if (state.currentPlayerName && !submittedThisGame) {
                submitScore(state.currentPlayerName, { after: 'reset' });
              }
            }

            if (justHitMilestone) {
              if (milestoneTimeoutId) clearTimeout(milestoneTimeoutId);
              setStatus(`¡Has llegado a ${m}!`);
              milestoneMessageActive = true;
              milestoneStartTime = Date.now(); // Limpiar después de 5 segundos
              milestoneTimeoutId = setTimeout(() => {
                statusEl.style.opacity = '0';
                setTimeout(() => setStatus(''), 1000);
              }, 5000);
              // No mostrar form, enviar automáticamente si hay nombre
              if (state.currentPlayerName && !submittedThisGame) {
                submitScore(state.currentPlayerName, { after: 'continue' });
              }
            }

            // Pop merged destinations after the board updates.
            if (result.mergeDestinations.length) {
              result.mergeDestinations.forEach((idx) => {
                const el = cells[idx];
                if (!el) return;
                el.classList.remove('m2048__cell--pop');
                // Force reflow so repeated merges still animate.
                void el.offsetWidth;
                el.classList.add('m2048__cell--pop');
                setTimeout(() => el.classList.remove('m2048__cell--pop'), 220);
              });
            }
          })
          .finally(() => {
            isAnimating = false;
          });
      };

      const onKeyDown = (e) => {
        const key = e.key;
        if (key === 'ArrowLeft') { e.preventDefault(); move('left'); }
        else if (key === 'ArrowRight') { e.preventDefault(); move('right'); }
        else if (key === 'ArrowUp') { e.preventDefault(); move('up'); }
        else if (key === 'ArrowDown') { e.preventDefault(); move('down'); }
      };

      let startX = 0;
      let startY = 0;
      const onPointerDown = (e) => {
        startX = e.clientX;
        startY = e.clientY;
      };
      const onPointerUp = (e) => {
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        const ax = Math.abs(dx);
        const ay = Math.abs(dy);
        if (Math.max(ax, ay) < 18) return;
        if (ax > ay) move(dx > 0 ? 'right' : 'left');
        else move(dy > 0 ? 'down' : 'up');
      };

      boardEl.addEventListener('keydown', onKeyDown);
      boardEl.addEventListener('pointerdown', onPointerDown);
      boardEl.addEventListener('pointerup', onPointerUp);

      // Click/focus to enable keyboard control.
      boardEl.addEventListener('pointerdown', () => {
        try { boardEl.focus(); } catch (_) {}
      });

      newBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        // Dev cheat: Ctrl/Cmd + click opens prompts to set score/max tile for testing.
        if ((e.ctrlKey || e.metaKey) && DEBUG_CHEAT) {
          try {
            const scoreInput = prompt('Cheat: Puntuación deseada (dejar vacío para no cambiar)');
            const maxInput = prompt('Cheat: Valor de la pieza máxima (p.ej. 2048). Dejar vacío para no cambiar');
            if (scoreInput != null && String(scoreInput).trim() !== '') {
              const n = Number(scoreInput);
              if (Number.isFinite(n)) state.score = Math.max(0, Math.floor(n));
            }
            if (maxInput != null && String(maxInput).trim() !== '') {
              const v = Number(maxInput);
              if (Number.isFinite(v) && v > 0) {
                // Place the requested tile in the first empty slot or replace index 0.
                const empties = emptyIndexes();
                const idx = (empties && empties.length) ? empties[0] : 0;
                state.board[idx] = Math.floor(v);
              }
            }
            // Recompute milestone and render.
            const m = milestoneForMax(maxTile());
            if (m && m > (state.lastMilestone || 0)) {
              state.lastMilestone = m;
              state.submittedMilestone = false;
              setStatus(`¡Has llegado a ${m}!`);
            }
            render();
          } catch (err) {
            console.error('[Mini-2048] Cheat failed:', err);
          }
          return;
        }

        const ok = confirm('¿Empezar una nueva partida? Se perderá el progreso actual.');
        if (!ok) return;
        reset();
      });

      changeNameBtn?.addEventListener('click', () => {
        if (state.currentPlayerName) {
          const newName = prompt('Nuevo nombre:');
          if (newName && newName.trim()) {
            const ok = confirm('Cambiar nombre reiniciará la partida. ¿Continuar?');
            if (ok) {
              setCurrentPlayerName(newName.trim());
              reset();
            }
          }
        } else {
          const newName = prompt('Introducir nombre:');
          if (newName && newName.trim()) {
            setCurrentPlayerName(newName.trim());
          }
        }
      });

      lbRefreshBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        fetchLeaderboard();
      });

      // Show leaderboard info as browser alert.
      if (lbInfoEl) {
        lbInfoEl.addEventListener('click', () => {
          alert('Cómo funciona el juego y el Leaderboard\n\n- La partida se guarda en este dispositivo, aunque recargues la página.\n- Tu puntuación se subirá al Leaderboard automáticamente al conseguir las fichas 256, 512, 1024, 2048... (y todas las siguientes), cada 1000 puntos extra, o cuando termina la partida.\n- Si ya existe tu nombre, solo se actualiza si mejoras tu puntuación.\n- Nombre: 1–16 caracteres. Permitidos letras/números/espacios y ._-.');
        });
      }

      if (!load()) reset();
      else render();

      // If a saved game is already blocked, reflect it immediately.
      if (!canMove()) {
        setGameOver(true);
        setStatus('¡Game Over!');
        if (state.currentPlayerName && !submittedThisGame) {
          submitScore(state.currentPlayerName, { after: 'reset' });
        }
      } else {
        // No mostrar mensaje de milestone al cargar, es información pasada
      }

      // Load leaderboard once on init.
      fetchLeaderboard();
    };

    const boot = () => {
      const roots = Array.from(document.querySelectorAll('.m2048'));
      roots.forEach(init);
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', boot, { once: true });
    } else {
      boot();
    }
  })();
</script>