<!DOCTYPE html><html lang="es"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>setupandhold</title><meta name="description" content="Bitácora sobre tecnología."><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet"><script>
      const storageKey = 'theme';
      const prefersLight = window.matchMedia('(prefers-color-scheme: light)').matches;
      const saved = localStorage.getItem(storageKey);
      const theme = saved || (prefersLight ? 'light' : 'dark');
      document.documentElement.dataset.theme = theme;
    </script><link rel="stylesheet" href="/_astro/about.CKaqEIRE.css">
<link rel="stylesheet" href="/_astro/index.DASO61d0.css"></head> <body> <div class="page-shell"> <header class="site-header"> <a class="brand" href="/"> <img class="brand-logo" src="/favicon.svg" alt="setupandhold" width="24" height="24"> <span>setupandhold</span> </a> <nav class="nav-links"> <a href="/">Inicio</a> <a href="/posts">Blog</a> <a href="/puzzle" rel="prefetch">Puzzle</a> <a href="/mousepad">Alfombrilla</a> <a href="/about">Sobre mi</a> </nav> </header> <main class="page">  <section class="home-layout" data-astro-cid-j7pv25f6> <div class="home-main" data-astro-cid-j7pv25f6> <section class="hero" data-astro-cid-j7pv25f6> <div class="hero-copy" data-astro-cid-j7pv25f6> <h1 data-astro-cid-j7pv25f6>Setup & Hold</h1> <p data-astro-cid-j7pv25f6>
Bitácora ligera para documentar ideas, experimentos y proyectos.
</p> <div class="hero-actions" data-astro-cid-j7pv25f6> <a class="button" href="/posts" data-astro-cid-j7pv25f6>Leer el blog</a> <a class="button" href="/puzzle" rel="prefetch" data-astro-cid-j7pv25f6>Puzzle Generator</a> <a class="button" href="/mousepad" data-astro-cid-j7pv25f6>Alfombrilla ASIC</a> </div> </div> </section> <div class="section-title" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>Entradas recientes</h2> <a class="button secondary" href="/posts" data-astro-cid-j7pv25f6>Ver todas</a> </div> <div class="post-grid" data-astro-cid-j7pv25f6> <article class="post-card"> <a class="card-link" href="/posts/bienvenida"> <div class="card-meta"> <span class="pill">3 ene 2026</span> <div class="tag-row"> <span class="tag" aria-label="Etiqueta setup">setup</span><span class="tag" aria-label="Etiqueta hold">hold</span><span class="tag" aria-label="Etiqueta astro">astro</span><span class="tag" aria-label="Etiqueta proyectos">proyectos</span> </div> </div> <h3>Bienvenida a setupandhold</h3> <p>Un poco sobre mí, el porqué del sitio y qué proyectos puedes ver ahora mismo.</p> </a> </article> </div> </div> <aside class="home-side" aria-label="Juego 2048" data-astro-cid-j7pv25f6> <section class="m2048" aria-label="Juego 2048" data-storage-key="mini-2048-state-v2" data-api-base="https://setupandhold-leaderboard.jordimorosbadenes.workers.dev" data-astro-cid-3tqk6umu> <header class="m2048__header" data-astro-cid-3tqk6umu> <div class="m2048__head" data-astro-cid-3tqk6umu> <div class="m2048__topline" data-astro-cid-3tqk6umu> <h2 class="m2048__title" data-astro-cid-3tqk6umu>Mini-2048</h2> <div class="m2048__score" data-astro-cid-3tqk6umu> <span class="m2048__label" data-astro-cid-3tqk6umu>Puntos</span> <span class="m2048__value" data-score data-astro-cid-3tqk6umu>0</span> </div> </div> <div class="m2048__subline" data-astro-cid-3tqk6umu> <p class="m2048__hint" data-astro-cid-3tqk6umu>¡Une las fichas y llega a 2048!</p> </div> </div> </header> <div class="m2048__board" data-board tabindex="0" role="application" aria-label="Tablero 2048" data-astro-cid-3tqk6umu> <div class="m2048__cell" data-cell="0" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="1" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="2" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="3" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="4" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="5" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="6" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="7" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="8" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="9" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="10" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="11" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="12" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="13" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="14" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="15" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div> </div> <p class="m2048__note" data-status aria-live="polite" data-astro-cid-3tqk6umu></p> <form class="m2048__submit" data-submit hidden data-astro-cid-3tqk6umu> <div class="m2048__submit-row" data-astro-cid-3tqk6umu> <label class="m2048__submit-label" for="m2048-name" data-astro-cid-3tqk6umu>Tu nombre</label> <input id="m2048-name" class="m2048__input" name="name" type="text" maxlength="16" placeholder="John Cena" autocomplete="nickname" data-name required data-astro-cid-3tqk6umu> </div> <div class="m2048__submit-row m2048__submit-row--actions" data-astro-cid-3tqk6umu> <button class="m2048__btn" type="submit" data-submit-btn data-astro-cid-3tqk6umu>Enviar puntuación</button> <span class="m2048__lb-muted" data-submit-msg data-astro-cid-3tqk6umu></span> </div> </form> <div class="m2048__actions" aria-label="Acciones" data-actions data-astro-cid-3tqk6umu> <button class="m2048__btn" type="button" data-new data-astro-cid-3tqk6umu>Nueva partida</button> </div> <section class="m2048__leaderboard" aria-label="Leaderboard" data-astro-cid-3tqk6umu> <div class="m2048__lb-header" data-astro-cid-3tqk6umu> <h3 class="m2048__lb-title" data-astro-cid-3tqk6umu>Leaderboard</h3> <div class="m2048__lb-actions" data-astro-cid-3tqk6umu> <details class="m2048__lb-info" data-lb-info data-astro-cid-3tqk6umu> <summary class="m2048__lb-info-btn" aria-label="Info del leaderboard" title="Info" data-astro-cid-3tqk6umu>i</summary> <div class="m2048__lb-info-panel" role="note" data-astro-cid-3tqk6umu> <p class="m2048__lb-info-title" data-astro-cid-3tqk6umu>Cómo funciona</p> <ul class="m2048__lb-info-list" data-astro-cid-3tqk6umu> <li data-astro-cid-3tqk6umu>La partida se guarda en este dispositivo, aunque recargues la página.</li> <li data-astro-cid-3tqk6umu>Puedes enviar tu puntuación al Leaderboard al llegar a 2048+ (y siguientes hitos) o cuando termina la partida (¡Game Over!).</li> <li data-astro-cid-3tqk6umu>Si ya existe tu nombre, solo se actualiza si mejoras tu puntuación.</li> <li data-astro-cid-3tqk6umu>Nombre: 1–16 caracteres. Permitidos letras/números/espacios y <span class="m2048__mono" data-astro-cid-3tqk6umu>._-</span>.</li> </ul> </div> </details> <button class="m2048__icon-btn" type="button" data-lb-refresh aria-label="Actualizar leaderboard" title="Actualizar" data-astro-cid-3tqk6umu> <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true" focusable="false" data-astro-cid-3tqk6umu> <path fill="currentColor" d="M12 6a6 6 0 0 1 5.65 4H20l-3.2 3.2A.75.75 0 0 1 15.5 12.7V10h1.6A5.1 5.1 0 0 0 12 6.9c-1.62 0-3.1.76-4.05 1.94a.75.75 0 1 1-1.17-.93A6.6 6.6 0 0 1 12 5.4Zm-5.65 8H4l3.2-3.2a.75.75 0 0 1 1.3.53V14H6.9A5.1 5.1 0 0 0 12 17.1c1.62 0 3.1-.76 4.05-1.94a.75.75 0 0 1 1.17.93A6.6 6.6 0 0 1 12 18.6a6 6 0 0 1-5.65-4Z" data-astro-cid-3tqk6umu></path> </svg> </button> </div> </div> <div class="m2048__lb-cols" aria-hidden="true" data-astro-cid-3tqk6umu> <span class="m2048__lb-col-rank m2048__lb-rank" data-astro-cid-3tqk6umu>#</span> <span class="m2048__lb-col-name m2048__lb-name" data-astro-cid-3tqk6umu>Player</span> <span class="m2048__lb-col-tail" data-astro-cid-3tqk6umu> <span class="m2048__lb-col-label m2048__lb-score" data-astro-cid-3tqk6umu>Score</span> <span class="m2048__lb-col-label m2048__lb-max" data-astro-cid-3tqk6umu>Max</span> <span class="m2048__lb-col-label m2048__lb-date" data-astro-cid-3tqk6umu>Date</span> </span> </div> <ol class="m2048__lb-list" data-lb-list data-astro-cid-3tqk6umu></ol> <p class="m2048__lb-muted" data-lb-muted data-astro-cid-3tqk6umu></p> </section> </section>  <script>
  (() => {
    // Debug flag: set to 1 to enable developer cheat (Ctrl/Cmd+click new game),
    // set to 0 to disable.
    const DEBUG_CHEAT = 0;
    const init = (root) => {
      if (root.dataset.m2048Init === '1') return;
      root.dataset.m2048Init = '1';

      const boardEl = root.querySelector('[data-board]');
      const scoreEl = root.querySelector('[data-score]');
      const statusEl = root.querySelector('[data-status]');
      const newBtn = root.querySelector('[data-new]');
      const actionsEl = root.querySelector('[data-actions]');
      const cells = Array.from(root.querySelectorAll('[data-cell]'));
      const lbListEl = root.querySelector('[data-lb-list]');
      const lbColsEl = root.querySelector('.m2048__lb-cols');
      const lbMutedEl = root.querySelector('[data-lb-muted]');
      const lbRefreshBtn = root.querySelector('[data-lb-refresh]');
      const lbInfoEl = root.querySelector('[data-lb-info]');
      const submitForm = root.querySelector('[data-submit]');
      const nameInput = root.querySelector('[data-name]');
      const submitBtn = root.querySelector('[data-submit-btn]');
      const submitMsgEl = root.querySelector('[data-submit-msg]');

      if (!boardEl || cells.length !== 16) return;

      // Layer for animated tiles (prevents offset bugs).
      let overlayEl = boardEl.querySelector('.m2048__overlay');
      if (!overlayEl) {
        overlayEl = document.createElement('div');
        overlayEl.className = 'm2048__overlay';
        boardEl.appendChild(overlayEl);
      }

      const size = 4;
      const total = size * size;
      const storageKey = root.getAttribute('data-storage-key') || 'mini-2048-state-v2';
      const apiBase = (root.getAttribute('data-api-base') || '').trim();
      const normalizedApi = apiBase.replace(/\/+$/, '');
      const leaderboardEndpoint = (() => {
        if (!normalizedApi) return '';
        // Allow passing either the base URL or the full endpoint URL.
        if (/\/api\/leaderboard$/i.test(normalizedApi) || /\/leaderboard$/i.test(normalizedApi)) return normalizedApi;
        return `${normalizedApi}/api/leaderboard`;
      })();

      const state = {
        board: new Array(total).fill(0),
        score: 0,
        milestone: 2048,
        lastMilestone: 0,
        submittedMilestone: false,
      };

      let isAnimating = false;
      let isGameOver = false;
      let submittedThisGame = false;

      // Hitos para permitir guardar sin terminar la partida.
      // 2048, 4096, 8192... con un límite lógico.
      const milestoneMin = 2048;
      // Tope de hitos (nota: los hitos son potencias de 2; el último hito será
      // la mayor potencia de 2 <= milestoneMax).
      const milestoneMax = 131972;

      const maxTile = () => {
        let m = 0;
        for (let i = 0; i < state.board.length; i += 1) {
          const v = state.board[i] || 0;
          if (v > m) m = v;
        }
        return m;
      };

      const milestoneForMax = (m) => {
        if (m < milestoneMin) return 0;
        let v = milestoneMin;
        while (v <= milestoneMax / 2 && v * 2 <= m) v *= 2;
        return v;
      };

      const setGameOver = (value) => {
        isGameOver = value;
        if (value) root.setAttribute('data-gameover', '1');
        else root.removeAttribute('data-gameover');

        if (!value && submitForm) submitForm.hidden = true;
        if (actionsEl) actionsEl.hidden = false;
      };

      const lastNameKey = `${storageKey}::last-name`;
      const getLastName = () => {
        try { return localStorage.getItem(lastNameKey) || ''; } catch { return ''; }
      };
      const setLastName = (name) => {
        try { localStorage.setItem(lastNameKey, name); } catch {}
      };

      const showSubmit = (show, opts = {}) => {
        if (!submitForm) return;

        const reason = String(opts.reason || '').toLowerCase();
        const isMilestone = reason === 'milestone';
        const shouldShow = Boolean(show && !submittedThisGame && (isGameOver || isMilestone));
        submitForm.hidden = !shouldShow;

        // El botón de nueva partida siempre está visible.
        if (actionsEl) actionsEl.hidden = false;

        if (submitBtn) {
          // Reset classes
          submitBtn.classList.remove('m2048__btn--milestone');
          // Set text and style
          if (isMilestone && shouldShow) {
            submitBtn.textContent = 'Enviar puntuación y continuar partida';
            submitBtn.classList.add('m2048__btn--milestone');
          } else if (isGameOver && shouldShow) {
            submitBtn.textContent = 'Enviar puntuación';
          } else {
            submitBtn.textContent = 'Enviar puntuación';
          }
        }

        if (shouldShow && nameInput) {
          const val = (nameInput.value || '').trim();
          if (!val) nameInput.value = getLastName();

          const shouldFocus = opts.focus !== false && !isMilestone;
          if (shouldFocus) {
            try { nameInput.focus(); } catch {}
          }
        }
      };

      const setSubmitMsg = (text) => {
        if (!submitMsgEl) return;
        submitMsgEl.textContent = text || '';
      };

      const renderLeaderboard = (entries) => {
        if (!lbListEl) return;

        // Clean up any previous auto-scroll timers (re-render can happen on refresh/submit).
        if (Array.isArray(renderLeaderboard._timers)) {
          renderLeaderboard._timers.forEach((id) => {
            clearTimeout(id);
            clearInterval(id);
          });
        }
        renderLeaderboard._timers = [];
        if (Array.isArray(renderLeaderboard._rafIds)) {
          renderLeaderboard._rafIds.forEach((id) => {
            try { cancelAnimationFrame(id); } catch {}
          });
        }
        renderLeaderboard._rafIds = [];

        lbListEl.innerHTML = '';
        const safe = Array.isArray(entries) ? entries.slice(0, 10) : [];
        if (!safe.length) return;

        const fmtDate = new Intl.DateTimeFormat('es-ES', {
          year: '2-digit',
          month: '2-digit',
          day: '2-digit',
        });

        const startAutoScroll = (el) => {
          if (!el) return;
          const prefersReduced = typeof window !== 'undefined'
            && typeof window.matchMedia === 'function'
            && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
          if (prefersReduced) return;

          const scrollToLeft = (left, smooth) => {
            // Robust across browsers: options object may not be supported everywhere.
            try {
              if (typeof el.scrollTo === 'function') {
                try {
                  el.scrollTo({ left, top: 0, behavior: smooth ? 'smooth' : 'auto' });
                  return;
                } catch {
                  el.scrollTo(left, 0);
                  return;
                }
              }
            } catch {}
            try { el.scrollLeft = left; } catch {}
          };

          // NOTE: native smooth scrolling has an implementation-defined duration.
          // We animate manually so `travelMs` actually controls the speed.
          const animateTo = (targetLeft, durationMs) => {
            const from = Number(el.scrollLeft) || 0;
            const to = Number(targetLeft) || 0;
            const d = Math.max(0, Number(durationMs) || 0);
            if (d <= 0 || from === to) {
              scrollToLeft(to, false);
              return;
            }

            const start = (typeof performance !== 'undefined' && performance.now)
              ? performance.now()
              : Date.now();

            const easeInOutQuad = (t) => (t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2);

            const step = (now) => {
              const current = (typeof now === 'number') ? now : ((typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now());
              const t = Math.min(1, (current - start) / d);
              const eased = easeInOutQuad(t);
              el.scrollLeft = from + (to - from) * eased;
              if (t < 1) {
                const id = requestAnimationFrame(step);
                renderLeaderboard._rafIds.push(id);
              }
            };

            const id = requestAnimationFrame(step);
            renderLeaderboard._rafIds.push(id);
          };

          // Wait one frame so layout/scrollWidth are correct.
          requestAnimationFrame(() => {
            const max = el.scrollWidth - el.clientWidth;
            if (!(max > 4)) return;

            // Start from the left so the score is always the first thing visible.
            scrollToLeft(0, false);

            const dwellLeftMs = 3000; // 6 segundos a la izquierda
            const dwellRightMs = 3000; // 3 segundos a la derecha
            const travelMs = Math.max(1500, Math.min(4500, 1200 + max * 6))

            const cycle = () => {
              const m = el.scrollWidth - el.clientWidth;
              if (!(m > 4)) return;

              // Hold at left.
              scrollToLeft(0, false);
              const t1 = setTimeout(() => {
                // Smooth scroll to right.
                animateTo(m, travelMs);
                const t2 = setTimeout(() => {
                  // Hold at right.
                  scrollToLeft(m, false);
                  const t3 = setTimeout(() => {
                    // Smooth scroll back to left.
                    animateTo(0, travelMs);
                    const t4 = setTimeout(cycle, travelMs + 50);
                    renderLeaderboard._timers.push(t4);
                  }, dwellRightMs);
                  renderLeaderboard._timers.push(t3);
                }, travelMs + 50);
                renderLeaderboard._timers.push(t2);
              }, dwellLeftMs);
              renderLeaderboard._timers.push(t1);
            };

            cycle();
          });
        };

        for (let i = 0; i < safe.length; i += 1) {
          const e = safe[i];
          const li = document.createElement('li');
          li.className = 'm2048__lb-item';

          const rankSpan = document.createElement('span');
          rankSpan.className = 'm2048__lb-rank';
          rankSpan.textContent = String(i + 1);

          const nameSpan = document.createElement('span');
          nameSpan.className = 'm2048__lb-name';
          nameSpan.textContent = String(e?.name ?? '');
          const scoreSpan = document.createElement('span');
          scoreSpan.className = 'm2048__lb-score';
          scoreSpan.textContent = String(e?.score ?? '');

          const createdAt = typeof e?.createdAt === 'number' ? e.createdAt : Number(e?.createdAt);
          const dateSpan = document.createElement('span');
          dateSpan.className = 'm2048__lb-date';
          dateSpan.textContent = Number.isFinite(createdAt)
            ? fmtDate.format(new Date(createdAt * 1000))
            : '';

          const maxSpan = document.createElement('span');
          maxSpan.className = 'm2048__lb-max';
          maxSpan.textContent = String(e?.maxTile ?? '');

          li.appendChild(rankSpan);
          li.appendChild(nameSpan);

          const tail = document.createElement('span');
          tail.className = 'm2048__lb-tail';

          tail.appendChild(scoreSpan);
          tail.appendChild(maxSpan);
          tail.appendChild(dateSpan);
          li.appendChild(tail);
          lbListEl.appendChild(li);
        }

        // After rendering all rows, compute the widest name and fix the name column
        // width so all name cells share the same width (the widest one).
        requestAnimationFrame(() => {
          try {
            const nameEls = Array.from(lbListEl.querySelectorAll('.m2048__lb-name'));
            if (!nameEls.length) return;
            const widths = nameEls.map((el) => {
              const r = el.getBoundingClientRect();
              return Math.ceil(r.width);
            });
            const max = Math.max.apply(null, widths.concat([0]));
            if (max > 0) {
              const cols = `auto ${max}px 1fr`;
              if (lbColsEl && lbColsEl.style) lbColsEl.style.gridTemplateColumns = cols;
              const items = Array.from(lbListEl.querySelectorAll('.m2048__lb-item'));
              items.forEach((it) => { it.style.gridTemplateColumns = cols; });
              nameEls.forEach((el) => { el.style.width = `${max}px`; el.style.display = 'inline-block'; });
              // Also apply same fixed width to the header `Player` label so the
              // whole name column shares identical pixel width.
              try {
                const headerName = lbColsEl ? lbColsEl.querySelector('.m2048__lb-col-name') : null;
                if (headerName) { headerName.style.width = `${max}px`; headerName.style.display = 'inline-block'; }
              } catch (_) {}
            }
          } catch (_) {}
        });
        // Also measure tail columns (score, max, date) and fix their widths so each column
        // uses the maximum width found across rows; align header labels too.
        requestAnimationFrame(() => {
          try {
            const scoreEls = Array.from(lbListEl.querySelectorAll('.m2048__lb-score'));
            const maxEls = Array.from(lbListEl.querySelectorAll('.m2048__lb-max'));
            const dateEls = Array.from(lbListEl.querySelectorAll('.m2048__lb-date'));

            const measureMax = (els, minPx = 0) => {
              if (!els || !els.length) return 0;
              const w = els.map((el) => Math.ceil(el.getBoundingClientRect().width));
              return Math.max.apply(null, w.concat([minPx, 0]));
            };

            const scoreW = measureMax(scoreEls, 24);
            const maxW = measureMax(maxEls, 24);
            const dateW = measureMax(dateEls, 40);

            const headerTail = lbColsEl ? Array.from(lbColsEl.querySelectorAll('.m2048__lb-col-tail .m2048__lb-col-label')) : [];

            if (scoreW > 0) {
              scoreEls.forEach((el) => { el.style.width = `${scoreW}px`; el.style.display = 'inline-block'; });
              if (headerTail[0]) { headerTail[0].style.width = `${scoreW}px`; headerTail[0].style.display = 'inline-block'; }
            }
            if (maxW > 0) {
              maxEls.forEach((el) => { el.style.width = `${maxW}px`; el.style.display = 'inline-block'; });
              if (headerTail[1]) { headerTail[1].style.width = `${maxW}px`; headerTail[1].style.display = 'inline-block'; }
            }
            if (dateW > 0) {
              dateEls.forEach((el) => { el.style.width = `${dateW}px`; el.style.display = 'inline-block'; });
              if (headerTail[2]) { headerTail[2].style.width = `${dateW}px`; headerTail[2].style.display = 'inline-block'; }
            }

            // Start auto-scroll now that widths are stable.
            const tailEls = Array.from(lbListEl.querySelectorAll('.m2048__lb-tail'));
            tailEls.forEach((t) => startAutoScroll(t));
            // Make header tail align exactly with row tail columns and mirror
            // the scrollLeft so labels sit over their corresponding columns.
            try {
              const headerTailEl = lbColsEl ? lbColsEl.querySelector('.m2048__lb-col-tail') : null;
              if (headerTailEl) {
                const firstTail = tailEls[0];
                if (firstTail && firstTail.clientWidth) {
                  try { headerTailEl.style.width = `${firstTail.clientWidth}px`; } catch (_) {}
                }

                if (firstTail && firstTail.scrollWidth > firstTail.clientWidth) {
                  try {
                    // Create an inner wrapper inside the header tail to move with
                    // CSS transforms (GPU-accelerated), avoiding scrollLeft updates
                    // on the header which can cause jank.
                    headerTailEl.style.overflow = 'hidden';
                    // Apply the same fixed column widths to the inner wrapper.
                    let inner = headerTailEl.querySelector('.m2048__lb-col-tail-inner');
                    if (!inner) {
                      inner = document.createElement('div');
                      inner.className = 'm2048__lb-col-tail-inner';
                      // Move existing children into the inner wrapper.
                      while (headerTailEl.firstChild) inner.appendChild(headerTailEl.firstChild);
                      headerTailEl.appendChild(inner);
                      inner.style.display = 'inline-flex';
                      inner.style.gap = '12px';
                      inner.style.willChange = 'transform';
                      inner.style.whiteSpace = 'nowrap';
                    }
                    try {
                      inner.style.width = `${scoreW + maxW + dateW + 24}px`;
                      inner.style.boxSizing = 'content-box';
                    } catch (_) {}
                  } catch (_) {}

                  const firstTailForSync = firstTail;
                  const inner = headerTailEl.querySelector('.m2048__lb-col-tail-inner');
                  const sync = () => {
                    try {
                      const x = Math.max(0, firstTailForSync.scrollLeft || 0);
                      if (inner) inner.style.transform = `translateX(${-x}px)`;
                    } catch (_) {}
                    const id = requestAnimationFrame(sync);
                    renderLeaderboard._rafIds.push(id);
                  };
                  sync();
                }
              }
            } catch (_) {}
          } catch (_) {}
        });
      };

      // Store interval ids for cleanup.
      renderLeaderboard._timers = [];

      const setLbMuted = (text) => {
        if (!lbMutedEl) return;
        lbMutedEl.textContent = text || '';
      };

      const fetchLeaderboard = async () => {
        if (!leaderboardEndpoint) {
          setLbMuted('Leaderboard no configurado.');
          return;
        }
        try {
          if (lbRefreshBtn) {
            lbRefreshBtn.setAttribute('data-loading', '1');
            lbRefreshBtn.disabled = true;
          }
          setLbMuted('Cargando…');
          const res = await fetch(leaderboardEndpoint, { method: 'GET' });
          const data = await res.json();
          if (!res.ok || !data?.ok) throw new Error(data?.error || 'Error');
          renderLeaderboard(data.entries);
          if (!Array.isArray(data.entries) || data.entries.length === 0) setLbMuted('Aún no hay puntuaciones.');
          else setLbMuted('');
        } catch (e) {
          console.error('[Mini-2048] Leaderboard load failed:', e);
          setLbMuted('No se pudo cargar.');
        } finally {
          if (lbRefreshBtn) {
            lbRefreshBtn.removeAttribute('data-loading');
            lbRefreshBtn.disabled = false;
          }
        }
      };

      const submitScore = async (name, opts = {}) => {
        const after = String(opts.after || 'reset'); // 'reset' | 'continue'
        if (!leaderboardEndpoint) {
          setSubmitMsg('Leaderboard no configurado.');
          return;
        }
        try {
          setSubmitMsg('Enviando…');
          submitBtn && (submitBtn.disabled = true);

          const maxTileValue = maxTile();

          const res = await fetch(leaderboardEndpoint, {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ name, score: state.score, maxTile: maxTileValue }),
          });
          const data = await res.json();
          if (!res.ok || !data?.ok) throw new Error(data?.error || 'Error');

          renderLeaderboard(data.entries);
          setLbMuted('');

          if (after === 'reset') {
            submittedThisGame = true;
            localStorage.setItem(storageKey, JSON.stringify({ board: state.board, score: state.score, milestone: state.milestone, lastMilestone: state.lastMilestone, submittedMilestone: state.submittedMilestone, submittedThisGame: submittedThisGame }));
            // Keep the board and game over message, hide submit, show new game button
            showSubmit(false);
            setStatus('¡Game Over!');
            setGameOver(true);
            if (actionsEl) actionsEl.hidden = false;
          } else {
            // En hito, solo ocultamos el formulario y seguimos jugando.
            setSubmitMsg('');
            showSubmit(false);
            setStatus('');
            state.submittedMilestone = true;
            localStorage.setItem(storageKey, JSON.stringify({ board: state.board, score: state.score, milestone: state.milestone, lastMilestone: state.lastMilestone, submittedMilestone: state.submittedMilestone }));
          }
        } catch (e) {
          console.error('[Mini-2048] Leaderboard submit failed:', e);
          const msg = (e && typeof e === 'object' && 'message' in e) ? String(e.message) : 'No se pudo enviar.';
          setSubmitMsg(msg || 'No se pudo enviar.');
        } finally {
          submitBtn && (submitBtn.disabled = false);
        }
      };

      const rand = (n) => Math.floor(Math.random() * n);
      const emptyIndexes = () => state.board
        .map((v, i) => (v === 0 ? i : -1))
        .filter((i) => i !== -1);

      const spawn = () => {
        const empties = emptyIndexes();
        if (!empties.length) return;
        const idx = empties[rand(empties.length)];
        state.board[idx] = Math.random() < 0.9 ? 2 : 4;
      };

      const save = () => {
        try {
          localStorage.setItem(storageKey, JSON.stringify({ board: state.board, score: state.score, milestone: state.milestone, lastMilestone: state.lastMilestone, submittedMilestone: state.submittedMilestone, submittedThisGame: submittedThisGame }));
        } catch (_) {}
      };

      const render = () => {
        if (scoreEl) scoreEl.textContent = String(state.score);

        for (let i = 0; i < total; i += 1) {
          const v = state.board[i] || 0;
          const el = cells[i];
          if (!el) continue;
          el.textContent = v ? String(v) : '';
          el.setAttribute('data-value', String(v));
          el.setAttribute('aria-label', v ? `Casilla ${v}` : 'Casilla vacía');
          if (v >= 1000) {
            el.classList.add('m2048__cell--small-text');
          } else {
            el.classList.remove('m2048__cell--small-text');
          }
        }

        save();
      };

      const setStatus = (text) => {
        if (!statusEl) return;
        statusEl.textContent = text;
        if (text) statusEl.classList.add('m2048__note--accent');
        else statusEl.classList.remove('m2048__note--accent');
      };

      const reset = () => {
        state.board = new Array(total).fill(0);
        state.score = 0;
        state.milestone = 2048;
        state.lastMilestone = 0;
        state.submittedMilestone = false;
        spawn();
        spawn();
        setGameOver(false);
        submittedThisGame = false;
        localStorage.setItem(storageKey, JSON.stringify({ board: state.board, score: state.score, milestone: state.milestone, lastMilestone: state.lastMilestone, submittedMilestone: state.submittedMilestone, submittedThisGame: submittedThisGame }));
        setStatus('');
        setSubmitMsg('');
        showSubmit(false);
        render();
      };

      const load = () => {
        try {
          const raw = localStorage.getItem(storageKey);
          if (!raw) return false;
          const parsed = JSON.parse(raw);
          if (!parsed || !Array.isArray(parsed.board) || parsed.board.length !== total) return false;
          state.board = parsed.board.map((n) => (typeof n === 'number' ? n : 0));
          state.score = typeof parsed.score === 'number' ? parsed.score : 0;
          state.milestone = typeof parsed.milestone === 'number' ? parsed.milestone : 2048;
          state.lastMilestone = typeof parsed.lastMilestone === 'number' ? parsed.lastMilestone : 0;
          state.submittedMilestone = typeof parsed.submittedMilestone === 'boolean' ? parsed.submittedMilestone : false;
          submittedThisGame = typeof parsed.submittedThisGame === 'boolean' ? parsed.submittedThisGame : false;
          return true;
        } catch (_) {
          return false;
        }
      };

      const get = (r, c) => state.board[r * size + c];
      const set = (r, c, v) => { state.board[r * size + c] = v; };

      const slideAndMergeLine = (line) => {
        const values = line.filter((n) => n !== 0);
        const out = [];
        let gained = 0;

        for (let i = 0; i < values.length; i += 1) {
          const current = values[i];
          const next = values[i + 1];
          if (next != null && current === next) {
            const merged = current + next;
            out.push(merged);
            gained += merged;
            i += 1;
          } else {
            out.push(current);
          }
        }

        while (out.length < size) out.push(0);
        return { out, gained };
      };

      const buildLines = (dir) => {
        const lines = [];
        for (let r = 0; r < size; r += 1) {
          const row = [r * size + 0, r * size + 1, r * size + 2, r * size + 3];
          if (dir === 'left') lines.push(row);
          else if (dir === 'right') lines.push(row.slice().reverse());
        }
        for (let c = 0; c < size; c += 1) {
          const col = [0 * size + c, 1 * size + c, 2 * size + c, 3 * size + c];
          if (dir === 'up') lines.push(col);
          else if (dir === 'down') lines.push(col.slice().reverse());
        }
        return lines;
      };

      const computeMove = (dir) => {
        const before = state.board.slice();
        const next = before.slice();
        const moves = [];
        const mergeDestinations = [];
        let gained = 0;

        const lines = buildLines(dir);
        for (const lineIdxs of lines) {
          const tiles = lineIdxs
            .filter((idx) => before[idx] !== 0)
            .map((idx) => ({ value: before[idx], from: idx }));

          const out = new Array(size).fill(0);
          let write = 0;
          for (let i = 0; i < tiles.length; i += 1) {
            const a = tiles[i];
            const b = tiles[i + 1];
            if (b && a.value === b.value) {
              const dest = lineIdxs[write];
              const mergedValue = a.value + b.value;
              out[write] = mergedValue;
              gained += mergedValue;
              moves.push({ from: a.from, to: dest, value: a.value, merged: true });
              moves.push({ from: b.from, to: dest, value: b.value, merged: true });
              mergeDestinations.push(dest);
              i += 1;
            } else {
              const dest = lineIdxs[write];
              out[write] = a.value;
              moves.push({ from: a.from, to: dest, value: a.value, merged: false });
            }
            write += 1;
          }

          for (let j = 0; j < size; j += 1) {
            next[lineIdxs[j]] = out[j];
          }
        }

        const changed = before.some((v, i) => v !== next[i]);
        return {
          before,
          next,
          moves,
          gained,
          mergeDestinations: Array.from(new Set(mergeDestinations)),
          changed,
        };
      };

      const animateMoves = async (moveResult) => {
        const isMobile = typeof window !== 'undefined'
          && typeof window.matchMedia === 'function'
          && window.matchMedia('(max-width: 720px)').matches;

        // En móvil damos un pelín más de tiempo y forzamos una secuencia de frames más fiable.
        // En escritorio lo dejamos tal cual para no cambiar sensaciones.
        const duration = isMobile ? 140 : 140;

        // Empieza lentamente (0.2) - la animación acelera gradualmente al inicio
        // Acelera mucho (0.9) - alcanza velocidad máxima rápidamente
        // Decelera suavemente (0.2) - reduce velocidad hacia el final
        // Termina normalmente (1) - llega al destino sin rebote
        const easing = 'cubic-bezier(0.2, 0.9, 0.2, 0.9)';

        // Most reliable: use layout offsets from the real grid items.
        const posForIndex = (idx) => {
          const el = cells[idx];
          return {
            left: el.offsetLeft,
            top: el.offsetTop,
            width: el.offsetWidth,
            height: el.offsetHeight,
          };
        };

        // Hide the text/values where tiles are leaving, to avoid double-vision.
        const leaving = new Set(
          moveResult.moves
            .filter((m) => m.from !== m.to)
            .map((m) => m.from)
        );
        leaving.forEach((idx) => {
          const el = cells[idx];
          if (!el) return;
          el.textContent = '';
          el.setAttribute('data-value', '0');
          el.setAttribute('aria-label', 'Casilla vacía');
        });

        const overlays = [];
        for (const m of moveResult.moves) {
          if (m.from === m.to) continue;

          const from = posForIndex(m.from);
          const to = posForIndex(m.to);

          const tile = document.createElement('div');
          tile.className = 'm2048__tile';
          tile.textContent = String(m.value);
          tile.setAttribute('data-value', String(m.value));
          if (m.value >= 1000) {
            tile.classList.add('m2048__tile--small-text');
          }
          tile.style.left = `${from.left}px`;
          tile.style.top = `${from.top}px`;
          tile.style.width = `${from.width}px`;
          tile.style.height = `${from.height}px`;
          if (isMobile) {
            tile.style.transform = 'translate3d(0px, 0px, 0px)';
            tile.style.transition = 'none';
          } else {
            tile.style.transform = 'translate(0px, 0px)';
            tile.style.transition = `transform ${duration}ms ${easing}`;
          }
          overlayEl.appendChild(tile);
          overlays.push(tile);

          const dx = to.left - from.left;
          const dy = to.top - from.top;
          if (isMobile) {
            // Doble rAF: asegura que el browser “registre” el estado inicial antes de animar.
            requestAnimationFrame(() => {
              tile.style.transition = `transform ${duration}ms ${easing}`;
              requestAnimationFrame(() => {
                tile.style.transform = `translate3d(${dx}px, ${dy}px, 0px)`;
              });
            });
          } else {
            requestAnimationFrame(() => {
              tile.style.transform = `translate(${dx}px, ${dy}px)`;
            });
          }
        }

        if (!overlays.length) return;

        await new Promise((resolve) => {
          let resolved = false;
          let remaining = overlays.length;

          const finish = () => {
            if (resolved) return;
            resolved = true;
            overlays.forEach((el) => el.remove());
            resolve();
          };

          overlays.forEach((el) => {
            const onEnd = (e) => {
              if (e.propertyName !== 'transform') return;
              el.removeEventListener('transitionend', onEnd);
              remaining -= 1;
              if (remaining <= 0) finish();
            };
            el.addEventListener('transitionend', onEnd);
          });

          setTimeout(finish, duration + 120);
        });
      };

      const canMove = () => {
        if (emptyIndexes().length) return true;
        for (let r = 0; r < size; r += 1) {
          for (let c = 0; c < size; c += 1) {
            const v = get(r, c);
            if (c + 1 < size && v === get(r, c + 1)) return true;
            if (r + 1 < size && v === get(r + 1, c)) return true;
          }
        }
        return false;
      };

      const has2048 = () => state.board.some((v) => v === 2048);

      const move = (dir) => {
        if (isAnimating) return;
        if (isGameOver) return;
        if (submitForm && !submitForm.hidden) return;

        const result = computeMove(dir);
        if (!result.changed) return;

        isAnimating = true;
        animateMoves(result)
          .then(() => {
            state.board = result.next;
            state.score += result.gained;
            
            // Remember which cells had values before spawning
            const hadValue = state.board.map(v => v !== 0);
            spawn();
            // Find which cell got a new value
            const newTileIndex = state.board.findIndex((v, i) => v !== 0 && !hadValue[i]);

            let m = milestoneForMax(maxTile());
            let justHitMilestone = Boolean(m && m > (state.lastMilestone || 0));
            if (justHitMilestone) {
              state.lastMilestone = m;
              state.submittedMilestone = false;
            }

            render();

            // Pop the new tile after render
            if (newTileIndex !== -1) {
              const el = cells[newTileIndex];
              if (el) {
                el.classList.remove('m2048__cell--appear');
                // Force reflow so animation works
                void el.offsetWidth;
                el.classList.add('m2048__cell--appear');
                setTimeout(() => el.classList.remove('m2048__cell--appear'), 250);
              }
            }

            if (!canMove()) {
              setGameOver(true);
              const reachedMilestone = maxTile() >= milestoneMin;
              if (reachedMilestone) {
                setStatus('¡Game Over!');
                if (!submittedThisGame) showSubmit(true, { reason: 'gameover' });
              } else {
                setStatus('¡Game Over! Debes llegar a 2048 o más para poder subir una puntuación.');
                showSubmit(false);
              }
            } else if (!justHitMilestone) {
              setStatus('');
            }

            if (justHitMilestone) {
              setStatus(`¡Has llegado a ${m}! Puedes enviar tu puntuación y seguir jugando.`);
              showSubmit(true, { reason: 'milestone', focus: false });
            }

            // Pop merged destinations after the board updates.
            if (result.mergeDestinations.length) {
              result.mergeDestinations.forEach((idx) => {
                const el = cells[idx];
                if (!el) return;
                el.classList.remove('m2048__cell--pop');
                // Force reflow so repeated merges still animate.
                void el.offsetWidth;
                el.classList.add('m2048__cell--pop');
                setTimeout(() => el.classList.remove('m2048__cell--pop'), 220);
              });
            }
          })
          .finally(() => {
            isAnimating = false;
          });
      };

      const onKeyDown = (e) => {
        const key = e.key;
        if (key === 'ArrowLeft') { e.preventDefault(); move('left'); }
        else if (key === 'ArrowRight') { e.preventDefault(); move('right'); }
        else if (key === 'ArrowUp') { e.preventDefault(); move('up'); }
        else if (key === 'ArrowDown') { e.preventDefault(); move('down'); }
      };

      let startX = 0;
      let startY = 0;
      const onPointerDown = (e) => {
        startX = e.clientX;
        startY = e.clientY;
      };
      const onPointerUp = (e) => {
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        const ax = Math.abs(dx);
        const ay = Math.abs(dy);
        if (Math.max(ax, ay) < 18) return;
        if (ax > ay) move(dx > 0 ? 'right' : 'left');
        else move(dy > 0 ? 'down' : 'up');
      };

      boardEl.addEventListener('keydown', onKeyDown);
      boardEl.addEventListener('pointerdown', onPointerDown);
      boardEl.addEventListener('pointerup', onPointerUp);

      // Click/focus to enable keyboard control.
      boardEl.addEventListener('pointerdown', () => {
        try { boardEl.focus(); } catch (_) {}
      });

      newBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        // Dev cheat: Ctrl/Cmd + click opens prompts to set score/max tile for testing.
        if ((e.ctrlKey || e.metaKey) && DEBUG_CHEAT) {
          try {
            const scoreInput = prompt('Cheat: Puntuación deseada (dejar vacío para no cambiar)');
            const maxInput = prompt('Cheat: Valor de la pieza máxima (p.ej. 2048). Dejar vacío para no cambiar');
            if (scoreInput != null && String(scoreInput).trim() !== '') {
              const n = Number(scoreInput);
              if (Number.isFinite(n)) state.score = Math.max(0, Math.floor(n));
            }
            if (maxInput != null && String(maxInput).trim() !== '') {
              const v = Number(maxInput);
              if (Number.isFinite(v) && v > 0) {
                // Place the requested tile in the first empty slot or replace index 0.
                const empties = emptyIndexes();
                const idx = (empties && empties.length) ? empties[0] : 0;
                state.board[idx] = Math.floor(v);
              }
            }
            // Recompute milestone and render.
            const m = milestoneForMax(maxTile());
            if (m && m > (state.lastMilestone || 0)) {
              state.lastMilestone = m;
              state.submittedMilestone = false;
              setStatus(`¡Has llegado a ${m}! Puedes enviar tu puntuación y seguir jugando.`);
              showSubmit(true, { reason: 'milestone', focus: false });
            }
            render();
          } catch (err) {
            console.error('[Mini-2048] Cheat failed:', err);
          }
          return;
        }

        const ok = confirm('¿Empezar una nueva partida? Se perderá el progreso actual.');
        if (!ok) return;
        reset();
      });

      lbRefreshBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        fetchLeaderboard();
      });

      // Close the leaderboard info <details> when clicking/tapping outside it.
      try {
        if (lbInfoEl) {
          const onDocPointer = (ev) => {
            try {
              if (!lbInfoEl.open) return;
              if (lbInfoEl.contains(ev.target)) return;
              lbInfoEl.open = false;
            } catch (_) {}
          };

          const onToggle = () => {
            try {
              if (lbInfoEl.open) {
                document.addEventListener('pointerdown', onDocPointer, { capture: true });
                document.addEventListener('touchstart', onDocPointer, { passive: true, capture: true });
              } else {
                document.removeEventListener('pointerdown', onDocPointer, { capture: true });
                document.removeEventListener('touchstart', onDocPointer, { capture: true });
              }
            } catch (_) {}
          };

          lbInfoEl.addEventListener('toggle', onToggle);
        }
      } catch (_) {}

      submitForm?.addEventListener('submit', (e) => {
        e.preventDefault();
        if (submittedThisGame) return;
        const name = String(nameInput?.value || '').trim();
        if (!name) {
          setSubmitMsg('Pon un nombre.');
          return;
        }
        setLastName(name);
        submitScore(name, { after: isGameOver ? 'reset' : 'continue' });
      });

      if (!load()) reset();
      else render();

      // If a saved game is already blocked, reflect it immediately.
      if (!canMove()) {
        setGameOver(true);
        const reachedMilestone = maxTile() >= milestoneMin;
        if (reachedMilestone) {
          setStatus('¡Game Over!');
          if (!submittedThisGame) showSubmit(true, { reason: 'gameover' });
        } else {
          setStatus('¡Game Over! Debes llegar a 2048 o más para poder subir una puntuación.');
          showSubmit(false);
        }
      } else {
        // Si el guardado ya había llegado a un hito, mostrar mensaje.
        if (state.lastMilestone > 0 && !state.submittedMilestone) {
          setStatus(`¡Has llegado a ${state.lastMilestone}! Puedes enviar tu puntuación y seguir jugando.`);
          showSubmit(true, { reason: 'milestone', focus: false });
        }
      }

      // Load leaderboard once on init.
      fetchLeaderboard();
    };

    const boot = () => {
      const roots = Array.from(document.querySelectorAll('.m2048'));
      roots.forEach(init);
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', boot, { once: true });
    } else {
      boot();
    }
  })();
</script> </aside> </section>  </main> <footer class="site-footer"> <span>© 2026 setupandhold</span> <span class="dot">·</span> <a href="https://github.com/jordimorosbadenes/setupandhold" target="_blank" rel="noreferrer">GitHub</a> <button class="theme-toggle" type="button" data-theme-toggle aria-pressed="false" aria-label="Cambiar tema"> <span class="toggle-slider"> <i class="slider-icon slider-icon--light fi fi-sc-brightness" aria-hidden="true"></i> <i class="slider-icon slider-icon--dark fi fi-sr-moon-stars" aria-hidden="true"></i> </span> </button> </footer> </div> <script>
    (() => {
      const key = 'theme';
      const apply = (value) => {
        document.documentElement.dataset.theme = value;
        localStorage.setItem(key, value);
        const btn = document.querySelector('[data-theme-toggle]');
        btn?.setAttribute('aria-pressed', value === 'light' ? 'true' : 'false');
      };
      const init = () => {
        const saved = localStorage.getItem(key);
        const prefersLight = window.matchMedia('(prefers-color-scheme: light)').matches;
        apply(saved || (prefersLight ? 'light' : 'dark'));
        const btn = document.querySelector('[data-theme-toggle]');
        btn?.addEventListener('click', () => {
          const current = document.documentElement.dataset.theme === 'light' ? 'light' : 'dark';
          apply(current === 'light' ? 'dark' : 'light');
        });
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script> </body></html> 