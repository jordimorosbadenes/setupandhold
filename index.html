<!DOCTYPE html><html lang="es"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>setupandhold</title><meta name="description" content="Notas cortas sobre software y datos."><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet"><script>
      const storageKey = 'theme';
      const prefersLight = window.matchMedia('(prefers-color-scheme: light)').matches;
      const saved = localStorage.getItem(storageKey);
      const theme = saved || (prefersLight ? 'light' : 'dark');
      document.documentElement.dataset.theme = theme;
    </script><link rel="stylesheet" href="/_astro/about.DDY32Zvp.css">
<link rel="stylesheet" href="/_astro/index.CkIulkfj.css"></head> <body> <div class="page-shell"> <header class="site-header"> <a class="brand" href="/"> <img class="brand-logo" src="/favicon.svg" alt="setupandhold" width="24" height="24"> <span>setupandhold</span> </a> <nav class="nav-links"> <a href="/">Inicio</a> <a href="/posts">Blog</a> <a href="/puzzle" rel="prefetch">Puzzle</a> <a href="/mousepad">Alfombrilla</a> <a href="/about">Sobre mi</a> </nav> </header> <main class="page">  <section class="home-layout" data-astro-cid-j7pv25f6> <div class="home-main" data-astro-cid-j7pv25f6> <section class="hero" data-astro-cid-j7pv25f6> <div class="hero-copy" data-astro-cid-j7pv25f6> <h1 data-astro-cid-j7pv25f6>Setup & Hold</h1> <p data-astro-cid-j7pv25f6>
Bitácora ligera para documentar ideas, experimentos y proyectos.
</p> <div class="hero-actions" data-astro-cid-j7pv25f6> <a class="button" href="/posts" data-astro-cid-j7pv25f6>Leer el blog</a> <a class="button" href="/puzzle" rel="prefetch" data-astro-cid-j7pv25f6>Puzzle Generator</a> <a class="button" href="/mousepad" data-astro-cid-j7pv25f6>Alfombrilla ASIC</a> </div> </div> </section> <div class="section-title" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>Entradas recientes</h2> <a class="button secondary" href="/posts" data-astro-cid-j7pv25f6>Ver todas</a> </div> <div class="post-grid" data-astro-cid-j7pv25f6> <article class="post-card"> <a class="card-link" href="/posts/bienvenida"> <div class="card-meta"> <span class="pill">3 ene 2026</span> <div class="tag-row"> <span class="tag" aria-label="Etiqueta setup">setup</span><span class="tag" aria-label="Etiqueta hold">hold</span><span class="tag" aria-label="Etiqueta astro">astro</span><span class="tag" aria-label="Etiqueta proyectos">proyectos</span> </div> </div> <h3>Bienvenida a setupandhold</h3> <p>Un poco sobre mí, el porqué del sitio y qué proyectos puedes ver ahora mismo.</p> </a> </article> </div> </div> <aside class="home-side" aria-label="Juego 2048" data-astro-cid-j7pv25f6> <section class="m2048" aria-label="Juego 2048" data-storage-key="mini-2048-state-v2" data-api-base="https://setupandhold-leaderboard.jordimorosbadenes.workers.dev" data-astro-cid-3tqk6umu> <header class="m2048__header" data-astro-cid-3tqk6umu> <div class="m2048__head" data-astro-cid-3tqk6umu> <div class="m2048__topline" data-astro-cid-3tqk6umu> <h2 class="m2048__title" data-astro-cid-3tqk6umu>Mini-2048</h2> <div class="m2048__score" data-astro-cid-3tqk6umu> <span class="m2048__label" data-astro-cid-3tqk6umu>Puntos</span> <span class="m2048__value" data-score data-astro-cid-3tqk6umu>0</span> </div> </div> <div class="m2048__subline" data-astro-cid-3tqk6umu> <p class="m2048__hint" data-astro-cid-3tqk6umu>¡Une las fichas y llega a 2048!</p> </div> </div> </header> <div class="m2048__board" data-board tabindex="0" role="application" aria-label="Tablero 2048" data-astro-cid-3tqk6umu> <div class="m2048__cell" data-cell="0" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="1" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="2" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="3" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="4" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="5" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="6" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="7" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="8" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="9" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="10" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="11" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="12" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="13" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="14" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div><div class="m2048__cell" data-cell="15" data-value="0" aria-label="Casilla vacía" data-astro-cid-3tqk6umu></div> </div> <p class="m2048__note" data-status aria-live="polite" data-astro-cid-3tqk6umu></p> <form class="m2048__submit" data-submit hidden data-astro-cid-3tqk6umu> <div class="m2048__submit-row" data-astro-cid-3tqk6umu> <label class="m2048__submit-label" for="m2048-name" data-astro-cid-3tqk6umu>Tu nombre</label> <input id="m2048-name" class="m2048__input" name="name" type="text" maxlength="16" placeholder="John Cena" autocomplete="nickname" data-name required data-astro-cid-3tqk6umu> </div> <div class="m2048__submit-row m2048__submit-row--actions" data-astro-cid-3tqk6umu> <button class="m2048__btn" type="submit" data-submit-btn data-astro-cid-3tqk6umu>Enviar puntuación y empezar nueva partida</button> <span class="m2048__lb-muted" data-submit-msg data-astro-cid-3tqk6umu></span> </div> </form> <div class="m2048__actions" aria-label="Acciones" data-actions data-astro-cid-3tqk6umu> <button class="m2048__btn" type="button" data-new data-astro-cid-3tqk6umu>Nueva partida</button> </div> <section class="m2048__leaderboard" aria-label="Leaderboard" data-astro-cid-3tqk6umu> <div class="m2048__lb-header" data-astro-cid-3tqk6umu> <h3 class="m2048__lb-title" data-astro-cid-3tqk6umu>Leaderboard</h3> <div class="m2048__lb-actions" data-astro-cid-3tqk6umu> <details class="m2048__lb-info" data-lb-info data-astro-cid-3tqk6umu> <summary class="m2048__lb-info-btn" aria-label="Info del leaderboard" title="Info" data-astro-cid-3tqk6umu>i</summary> <div class="m2048__lb-info-panel" role="note" data-astro-cid-3tqk6umu> <p class="m2048__lb-info-title" data-astro-cid-3tqk6umu>Cómo funciona</p> <ul class="m2048__lb-info-list" data-astro-cid-3tqk6umu> <li data-astro-cid-3tqk6umu>Solo se guarda la puntuación cuando termina la partida (¡Game Over!) y envías tu nombre.</li> <li data-astro-cid-3tqk6umu>Si ya existe tu nombre, solo se actualiza si mejoras tu puntuación.</li> <li data-astro-cid-3tqk6umu>Nombre: 1–16 caracteres. Permitidos letras/números/espacios y <span class="m2048__mono" data-astro-cid-3tqk6umu>._-</span>.</li> </ul> </div> </details> <button class="m2048__icon-btn" type="button" data-lb-refresh aria-label="Actualizar leaderboard" title="Actualizar" data-astro-cid-3tqk6umu> <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true" focusable="false" data-astro-cid-3tqk6umu> <path fill="currentColor" d="M12 6a6 6 0 0 1 5.65 4H20l-3.2 3.2A.75.75 0 0 1 15.5 12.7V10h1.6A5.1 5.1 0 0 0 12 6.9c-1.62 0-3.1.76-4.05 1.94a.75.75 0 1 1-1.17-.93A6.6 6.6 0 0 1 12 5.4Zm-5.65 8H4l3.2-3.2a.75.75 0 0 1 1.3.53V14H6.9A5.1 5.1 0 0 0 12 17.1c1.62 0 3.1-.76 4.05-1.94a.75.75 0 0 1 1.17.93A6.6 6.6 0 0 1 12 18.6a6 6 0 0 1-5.65-4Z" data-astro-cid-3tqk6umu></path> </svg> </button> </div> </div> <ol class="m2048__lb-list" data-lb-list data-astro-cid-3tqk6umu></ol> <p class="m2048__lb-muted" data-lb-muted data-astro-cid-3tqk6umu></p> </section> </section>  <script>
  (() => {
    const init = (root) => {
      if (root.dataset.m2048Init === '1') return;
      root.dataset.m2048Init = '1';

      const boardEl = root.querySelector('[data-board]');
      const scoreEl = root.querySelector('[data-score]');
      const statusEl = root.querySelector('[data-status]');
      const newBtn = root.querySelector('[data-new]');
      const actionsEl = root.querySelector('[data-actions]');
      const cells = Array.from(root.querySelectorAll('[data-cell]'));
      const lbListEl = root.querySelector('[data-lb-list]');
      const lbMutedEl = root.querySelector('[data-lb-muted]');
      const lbRefreshBtn = root.querySelector('[data-lb-refresh]');
      const submitForm = root.querySelector('[data-submit]');
      const nameInput = root.querySelector('[data-name]');
      const submitBtn = root.querySelector('[data-submit-btn]');
      const submitMsgEl = root.querySelector('[data-submit-msg]');

      if (!boardEl || cells.length !== 16) return;

      // Layer for animated tiles (prevents offset bugs).
      let overlayEl = boardEl.querySelector('.m2048__overlay');
      if (!overlayEl) {
        overlayEl = document.createElement('div');
        overlayEl.className = 'm2048__overlay';
        boardEl.appendChild(overlayEl);
      }

      const size = 4;
      const total = size * size;
      const storageKey = root.getAttribute('data-storage-key') || 'mini-2048-state-v2';
      const apiBase = (root.getAttribute('data-api-base') || '').trim();
      const normalizedApi = apiBase.replace(/\/+$/, '');
      const leaderboardEndpoint = (() => {
        if (!normalizedApi) return '';
        // Allow passing either the base URL or the full endpoint URL.
        if (/\/api\/leaderboard$/i.test(normalizedApi) || /\/leaderboard$/i.test(normalizedApi)) return normalizedApi;
        return `${normalizedApi}/api/leaderboard`;
      })();

      const state = {
        board: new Array(total).fill(0),
        score: 0,
      };

      let isAnimating = false;
      let isGameOver = false;
      let submittedThisGame = false;

      const setGameOver = (value) => {
        isGameOver = value;
        if (value) root.setAttribute('data-gameover', '1');
        else root.removeAttribute('data-gameover');

        if (!value && submitForm) submitForm.hidden = true;
        if (!value && actionsEl) actionsEl.hidden = false;
      };

      const lastNameKey = `${storageKey}::last-name`;
      const getLastName = () => {
        try { return localStorage.getItem(lastNameKey) || ''; } catch { return ''; }
      };
      const setLastName = (name) => {
        try { localStorage.setItem(lastNameKey, name); } catch {}
      };

      const showSubmit = (show) => {
        if (!submitForm) return;

        const shouldShow = Boolean(show && isGameOver && !submittedThisGame);
        submitForm.hidden = !shouldShow;

        // When submitting score, temporarily hide New Game to avoid replays/duplicate submits.
        if (actionsEl) actionsEl.hidden = shouldShow;

        if (shouldShow && nameInput) {
          const val = (nameInput.value || '').trim();
          if (!val) nameInput.value = getLastName();
          try { nameInput.focus(); } catch {}
        }
      };

      const setSubmitMsg = (text) => {
        if (!submitMsgEl) return;
        submitMsgEl.textContent = text || '';
      };

      const renderLeaderboard = (entries) => {
        if (!lbListEl) return;
        lbListEl.innerHTML = '';
        const safe = Array.isArray(entries) ? entries.slice(0, 10) : [];
        if (!safe.length) return;

        const fmtDate = new Intl.DateTimeFormat('es-ES', {
          year: '2-digit',
          month: '2-digit',
          day: '2-digit',
        });

        for (let i = 0; i < safe.length; i += 1) {
          const e = safe[i];
          const li = document.createElement('li');
          li.className = 'm2048__lb-item';

          const rankSpan = document.createElement('span');
          rankSpan.className = 'm2048__lb-rank';
          rankSpan.textContent = String(i + 1);

          const nameSpan = document.createElement('span');
          nameSpan.className = 'm2048__lb-name';
          nameSpan.textContent = String(e?.name ?? '');
          const scoreSpan = document.createElement('span');
          scoreSpan.className = 'm2048__lb-score';
          scoreSpan.textContent = String(e?.score ?? '');

          const createdAt = typeof e?.createdAt === 'number' ? e.createdAt : Number(e?.createdAt);
          const dateSpan = document.createElement('span');
          dateSpan.className = 'm2048__lb-date';
          dateSpan.textContent = Number.isFinite(createdAt)
            ? fmtDate.format(new Date(createdAt * 1000))
            : '';

          li.appendChild(rankSpan);
          li.appendChild(nameSpan);
          li.appendChild(scoreSpan);
          li.appendChild(dateSpan);
          lbListEl.appendChild(li);
        }
      };

      const setLbMuted = (text) => {
        if (!lbMutedEl) return;
        lbMutedEl.textContent = text || '';
      };

      const fetchLeaderboard = async () => {
        if (!leaderboardEndpoint) {
          setLbMuted('Leaderboard no configurado.');
          return;
        }
        try {
          if (lbRefreshBtn) {
            lbRefreshBtn.setAttribute('data-loading', '1');
            lbRefreshBtn.disabled = true;
          }
          setLbMuted('Cargando…');
          const res = await fetch(leaderboardEndpoint, { method: 'GET' });
          const data = await res.json();
          if (!res.ok || !data?.ok) throw new Error(data?.error || 'Error');
          renderLeaderboard(data.entries);
          if (!Array.isArray(data.entries) || data.entries.length === 0) setLbMuted('Aún no hay puntuaciones.');
          else setLbMuted('');
        } catch (e) {
          console.error('[Mini-2048] Leaderboard load failed:', e);
          setLbMuted('No se pudo cargar.');
        } finally {
          if (lbRefreshBtn) {
            lbRefreshBtn.removeAttribute('data-loading');
            lbRefreshBtn.disabled = false;
          }
        }
      };

      const submitScore = async (name) => {
        if (!leaderboardEndpoint) {
          setSubmitMsg('Leaderboard no configurado.');
          return;
        }
        try {
          setSubmitMsg('Enviando…');
          submitBtn && (submitBtn.disabled = true);

          const res = await fetch(leaderboardEndpoint, {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ name, score: state.score }),
          });
          const data = await res.json();
          if (!res.ok || !data?.ok) throw new Error(data?.error || 'Error');

          renderLeaderboard(data.entries);
          setLbMuted('');
          submittedThisGame = true;
          showSubmit(false);

          // Prevent re-submitting the same finished game later.
          // After a successful submission, start a fresh game (and persist it).
          reset();
        } catch (e) {
          console.error('[Mini-2048] Leaderboard submit failed:', e);
          const msg = (e && typeof e === 'object' && 'message' in e) ? String(e.message) : 'No se pudo enviar.';
          setSubmitMsg(msg || 'No se pudo enviar.');
        } finally {
          submitBtn && (submitBtn.disabled = false);
        }
      };

      const rand = (n) => Math.floor(Math.random() * n);
      const emptyIndexes = () => state.board
        .map((v, i) => (v === 0 ? i : -1))
        .filter((i) => i !== -1);

      const spawn = () => {
        const empties = emptyIndexes();
        if (!empties.length) return;
        const idx = empties[rand(empties.length)];
        state.board[idx] = Math.random() < 0.9 ? 2 : 4;
      };

      const save = () => {
        try {
          localStorage.setItem(storageKey, JSON.stringify({ board: state.board, score: state.score }));
        } catch (_) {}
      };

      const render = () => {
        if (scoreEl) scoreEl.textContent = String(state.score);

        for (let i = 0; i < total; i += 1) {
          const v = state.board[i] || 0;
          const el = cells[i];
          if (!el) continue;
          el.textContent = v ? String(v) : '';
          el.setAttribute('data-value', String(v));
          el.setAttribute('aria-label', v ? `Casilla ${v}` : 'Casilla vacía');
        }

        save();
      };

      const setStatus = (text) => {
        if (!statusEl) return;
        statusEl.textContent = text;
      };

      const reset = () => {
        state.board = new Array(total).fill(0);
        state.score = 0;
        spawn();
        spawn();
        setGameOver(false);
        submittedThisGame = false;
        setStatus('');
        setSubmitMsg('');
        showSubmit(false);
        render();
      };

      const load = () => {
        try {
          const raw = localStorage.getItem(storageKey);
          if (!raw) return false;
          const parsed = JSON.parse(raw);
          if (!parsed || !Array.isArray(parsed.board) || parsed.board.length !== total) return false;
          state.board = parsed.board.map((n) => (typeof n === 'number' ? n : 0));
          state.score = typeof parsed.score === 'number' ? parsed.score : 0;
          return true;
        } catch (_) {
          return false;
        }
      };

      const get = (r, c) => state.board[r * size + c];
      const set = (r, c, v) => { state.board[r * size + c] = v; };

      const slideAndMergeLine = (line) => {
        const values = line.filter((n) => n !== 0);
        const out = [];
        let gained = 0;

        for (let i = 0; i < values.length; i += 1) {
          const current = values[i];
          const next = values[i + 1];
          if (next != null && current === next) {
            const merged = current + next;
            out.push(merged);
            gained += merged;
            i += 1;
          } else {
            out.push(current);
          }
        }

        while (out.length < size) out.push(0);
        return { out, gained };
      };

      const buildLines = (dir) => {
        const lines = [];
        for (let r = 0; r < size; r += 1) {
          const row = [r * size + 0, r * size + 1, r * size + 2, r * size + 3];
          if (dir === 'left') lines.push(row);
          else if (dir === 'right') lines.push(row.slice().reverse());
        }
        for (let c = 0; c < size; c += 1) {
          const col = [0 * size + c, 1 * size + c, 2 * size + c, 3 * size + c];
          if (dir === 'up') lines.push(col);
          else if (dir === 'down') lines.push(col.slice().reverse());
        }
        return lines;
      };

      const computeMove = (dir) => {
        const before = state.board.slice();
        const next = before.slice();
        const moves = [];
        const mergeDestinations = [];
        let gained = 0;

        const lines = buildLines(dir);
        for (const lineIdxs of lines) {
          const tiles = lineIdxs
            .filter((idx) => before[idx] !== 0)
            .map((idx) => ({ value: before[idx], from: idx }));

          const out = new Array(size).fill(0);
          let write = 0;
          for (let i = 0; i < tiles.length; i += 1) {
            const a = tiles[i];
            const b = tiles[i + 1];
            if (b && a.value === b.value) {
              const dest = lineIdxs[write];
              const mergedValue = a.value + b.value;
              out[write] = mergedValue;
              gained += mergedValue;
              moves.push({ from: a.from, to: dest, value: a.value, merged: true });
              moves.push({ from: b.from, to: dest, value: b.value, merged: true });
              mergeDestinations.push(dest);
              i += 1;
            } else {
              const dest = lineIdxs[write];
              out[write] = a.value;
              moves.push({ from: a.from, to: dest, value: a.value, merged: false });
            }
            write += 1;
          }

          for (let j = 0; j < size; j += 1) {
            next[lineIdxs[j]] = out[j];
          }
        }

        const changed = before.some((v, i) => v !== next[i]);
        return {
          before,
          next,
          moves,
          gained,
          mergeDestinations: Array.from(new Set(mergeDestinations)),
          changed,
        };
      };

      const animateMoves = async (moveResult) => {
        const isMobile = typeof window !== 'undefined'
          && typeof window.matchMedia === 'function'
          && window.matchMedia('(max-width: 720px)').matches;

        // En móvil damos un pelín más de tiempo y forzamos una secuencia de frames más fiable.
        // En escritorio lo dejamos tal cual para no cambiar sensaciones.
        const duration = isMobile ? 170 : 140;
        const easing = 'cubic-bezier(0.2, 0.9, 0.2, 1)';

        // Most reliable: use layout offsets from the real grid items.
        const posForIndex = (idx) => {
          const el = cells[idx];
          return {
            left: el.offsetLeft,
            top: el.offsetTop,
            width: el.offsetWidth,
            height: el.offsetHeight,
          };
        };

        // Hide the text/values where tiles are leaving, to avoid double-vision.
        const leaving = new Set(
          moveResult.moves
            .filter((m) => m.from !== m.to)
            .map((m) => m.from)
        );
        leaving.forEach((idx) => {
          const el = cells[idx];
          if (!el) return;
          el.textContent = '';
          el.setAttribute('data-value', '0');
          el.setAttribute('aria-label', 'Casilla vacía');
        });

        const overlays = [];
        for (const m of moveResult.moves) {
          if (m.from === m.to) continue;

          const from = posForIndex(m.from);
          const to = posForIndex(m.to);

          const tile = document.createElement('div');
          tile.className = 'm2048__tile';
          tile.textContent = String(m.value);
          tile.setAttribute('data-value', String(m.value));
          tile.style.left = `${from.left}px`;
          tile.style.top = `${from.top}px`;
          tile.style.width = `${from.width}px`;
          tile.style.height = `${from.height}px`;
          if (isMobile) {
            tile.style.transform = 'translate3d(0px, 0px, 0px)';
            tile.style.transition = 'none';
          } else {
            tile.style.transform = 'translate(0px, 0px)';
            tile.style.transition = `transform ${duration}ms ${easing}`;
          }
          overlayEl.appendChild(tile);
          overlays.push(tile);

          const dx = to.left - from.left;
          const dy = to.top - from.top;
          if (isMobile) {
            // Doble rAF: asegura que el browser “registre” el estado inicial antes de animar.
            requestAnimationFrame(() => {
              tile.style.transition = `transform ${duration}ms ${easing}`;
              requestAnimationFrame(() => {
                tile.style.transform = `translate3d(${dx}px, ${dy}px, 0px)`;
              });
            });
          } else {
            requestAnimationFrame(() => {
              tile.style.transform = `translate(${dx}px, ${dy}px)`;
            });
          }
        }

        if (!overlays.length) return;

        await new Promise((resolve) => {
          let resolved = false;
          let remaining = overlays.length;

          const finish = () => {
            if (resolved) return;
            resolved = true;
            overlays.forEach((el) => el.remove());
            resolve();
          };

          overlays.forEach((el) => {
            const onEnd = (e) => {
              if (e.propertyName !== 'transform') return;
              el.removeEventListener('transitionend', onEnd);
              remaining -= 1;
              if (remaining <= 0) finish();
            };
            el.addEventListener('transitionend', onEnd);
          });

          setTimeout(finish, duration + 120);
        });
      };

      const canMove = () => {
        if (emptyIndexes().length) return true;
        for (let r = 0; r < size; r += 1) {
          for (let c = 0; c < size; c += 1) {
            const v = get(r, c);
            if (c + 1 < size && v === get(r, c + 1)) return true;
            if (r + 1 < size && v === get(r + 1, c)) return true;
          }
        }
        return false;
      };

      const has2048 = () => state.board.some((v) => v === 2048);

      const move = (dir) => {
        if (isAnimating) return;
        if (isGameOver) return;

        const result = computeMove(dir);
        if (!result.changed) return;

        isAnimating = true;
        animateMoves(result)
          .then(() => {
            state.board = result.next;
            state.score += result.gained;
            spawn();
            render();

            if (has2048()) {
              setStatus('¡2048!');
            } else if (!canMove()) {
              setGameOver(true);
              setStatus('¡Game Over!');
              if (!submittedThisGame) showSubmit(true);
            } else {
              setStatus('');
            }

            // Pop merged destinations after the board updates.
            if (result.mergeDestinations.length) {
              result.mergeDestinations.forEach((idx) => {
                const el = cells[idx];
                if (!el) return;
                el.classList.remove('m2048__cell--pop');
                // Force reflow so repeated merges still animate.
                void el.offsetWidth;
                el.classList.add('m2048__cell--pop');
                setTimeout(() => el.classList.remove('m2048__cell--pop'), 220);
              });
            }
          })
          .finally(() => {
            isAnimating = false;
          });
      };

      const onKeyDown = (e) => {
        const key = e.key;
        if (key === 'ArrowLeft') { e.preventDefault(); move('left'); }
        else if (key === 'ArrowRight') { e.preventDefault(); move('right'); }
        else if (key === 'ArrowUp') { e.preventDefault(); move('up'); }
        else if (key === 'ArrowDown') { e.preventDefault(); move('down'); }
      };

      let startX = 0;
      let startY = 0;
      const onPointerDown = (e) => {
        startX = e.clientX;
        startY = e.clientY;
      };
      const onPointerUp = (e) => {
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        const ax = Math.abs(dx);
        const ay = Math.abs(dy);
        if (Math.max(ax, ay) < 18) return;
        if (ax > ay) move(dx > 0 ? 'right' : 'left');
        else move(dy > 0 ? 'down' : 'up');
      };

      boardEl.addEventListener('keydown', onKeyDown);
      boardEl.addEventListener('pointerdown', onPointerDown);
      boardEl.addEventListener('pointerup', onPointerUp);

      // Click/focus to enable keyboard control.
      boardEl.addEventListener('pointerdown', () => {
        try { boardEl.focus(); } catch (_) {}
      });

      newBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        const ok = confirm('¿Empezar una nueva partida? Se perderá el progreso actual.');
        if (!ok) return;
        reset();
      });

      lbRefreshBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        fetchLeaderboard();
      });

      submitForm?.addEventListener('submit', (e) => {
        e.preventDefault();
        if (!isGameOver || submittedThisGame) return;
        const name = String(nameInput?.value || '').trim();
        if (!name) {
          setSubmitMsg('Pon un nombre.');
          return;
        }
        setLastName(name);
        submitScore(name);
      });

      if (!load()) reset();
      else render();

      // If a saved game is already blocked, reflect it immediately.
      if (!canMove()) {
        setGameOver(true);
        setStatus('¡Game Over!');
        if (!submittedThisGame) showSubmit(true);
      }

      // Load leaderboard once on init.
      fetchLeaderboard();
    };

    const boot = () => {
      const roots = Array.from(document.querySelectorAll('.m2048'));
      roots.forEach(init);
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', boot, { once: true });
    } else {
      boot();
    }
  })();
</script> </aside> </section>  </main> <footer class="site-footer"> <span>© 2026 setupandhold</span> <span class="dot">·</span> <a href="https://github.com/jordimorosbadenes/setupandhold" target="_blank" rel="noreferrer">GitHub</a> <button class="theme-toggle" type="button" data-theme-toggle aria-pressed="false" aria-label="Cambiar tema"> <span class="toggle-slider"> <i class="slider-icon slider-icon--light fi fi-sc-brightness" aria-hidden="true"></i> <i class="slider-icon slider-icon--dark fi fi-sr-moon-stars" aria-hidden="true"></i> </span> </button> </footer> </div> <script>
    (() => {
      const key = 'theme';
      const apply = (value) => {
        document.documentElement.dataset.theme = value;
        localStorage.setItem(key, value);
        const btn = document.querySelector('[data-theme-toggle]');
        btn?.setAttribute('aria-pressed', value === 'light' ? 'true' : 'false');
      };
      const init = () => {
        const saved = localStorage.getItem(key);
        const prefersLight = window.matchMedia('(prefers-color-scheme: light)').matches;
        apply(saved || (prefersLight ? 'light' : 'dark'));
        const btn = document.querySelector('[data-theme-toggle]');
        btn?.addEventListener('click', () => {
          const current = document.documentElement.dataset.theme === 'light' ? 'light' : 'dark';
          apply(current === 'light' ? 'dark' : 'light');
        });
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script> </body></html> 